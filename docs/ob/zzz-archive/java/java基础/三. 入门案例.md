## 三. 入门案例

这节课我们来学习 Java 的第一个入门程序，Hello world，目标是**命令** jvm，在程序窗口输出一行问候语。



###### 1. 第一行代码

######## 1) jshell

首先用到的是一个名为 jshell 的开发工具，打开命令提示符 cmd，输入 jshell

```shell
PS D:\> jshell
|  欢迎使用 JShell -- 版本 17.0.2
|  要大致了解该版本, 请键入: /help intro

jshell>
```

可以看到【jshell>】后的光标在不断闪烁，表示可以继续在【jshell>】后键入命令或代码

常见命令

* /help 帮助信息
* /exit 退出 jshell



第一行代码来了：输入 `System.out.println("Hello, world")`，要注意大小写和引号，查看效果



######## 2) 代码解读

下面来解释这行代码的意思

* 它的整体效果是命令 JVM，给我在在程序窗口输出一行话，话的内容是：`Hello, world`

再来把代码拆解，看看每一部分的意思

* 先要说明的是，咱们这个程序窗口内有两个较为抽象的组成部分，输出和输入

  * 其中输出的专业叫法是【标准输出】，用来将运算结果展现给用户，代码里就对应着 System.out 
  * 另一个是【标准输入】，用来接受用户输入的数据，代码里用 System.in 表示，后面再讲

  * System.out 、System.in 代表的这种计算机中的虚拟物体，以后统称之为【对象】
  * System.out 这个对象是 java 为我们提前准备好的
  * 以后还有一些对象是需要我们自己创建的，后面会逐渐讲到

但是光是拿到 System.out 对象，它并不会显示 Hello, world，我们必须给它下命令，也就是调用对象的功能

* println() 代表的是 System.out 中的一种功能，以后称之为【方法】
  * 方法的特征是在使用时会带有一对 ()
  * 不同的方法作用不同，println 方法的作用是将 () 内的内容展现到程序窗口并换行，System.out 对象还有 print 方法，区别是不换行输出内容
  * 前面的点，表示一种从属关系
    * 即 println() 方法从属于 System.out 对象，print 方法也从属于 System.out 对象
    * 从属关系决定了对象能否使用此方法，像 System.in 与 println 方法之间没有这种从属关系，就意味着 System.in 对象无法使用此 println 方法
    * 想知道对象和哪些方法之间有从属关系，后面会给大家讲解怎么查，目前了解这些足够了
* () 里面的 `"hello, world"` 叫做方法参数，你可以替换它为其它问候语
  * 不同的方法需要的参数个数及格式也有所不同，刚才我们用的这个 println 方法只接收了一个参数，以后大家可能见到不同个数和格式的参数，这些后面都会详细讲解




############ 总结

从这行代码中学习了什么呀，要命令计算机执行功能，可以借助【对象】、【方法】和【参数】来完成

* 刚才的例子中谁是对象？
  * System.out

* 它代表什么？
  * 标准输出 

* 谁是方法？
  * println 是方法

* 它有什么作用？
  * 不同方法作用不同，println 将括号内内容，也就是参数输出到程序窗口
  * 这其中参数比较自由，由我们提供，可以是 hello, world, 可以是你好，也可以是其它问候语

* 对象和方法是 java 提供的（当然以后我们也可以自己创建对象，定义新的方法，此乃后话）

至此为止，这行代码的含义讲解完毕



######## 3) 为何要分成对象与方法

有同学问：Java的设计者搞个输出都这么麻烦，还分成对象和方法俩概念，把它们合为一个概念不是更简单吗？你看

* 对象用来表示被操作的物体，是名词
* 方法用来告知让这个物体执行什么动作，是动词

这种划分更符合现实世界中对事物的认知，例如，你叫住【皮卡丘】，皮卡丘就是待操作的对象，这时候他还不知道要做什么。好，你命令他【趴下】，这个趴下就是方法，是皮卡丘要执行的动作，你再命令他【吃饭】，这个吃饭是另一个方法。可以看到，现实世界都可以这么划分，那么把计算机中的虚拟物体抽象成对象和方法，当然也是顺理成章啦，这符合人类对事物的认知。

因此，不要怕麻烦，以后在 java 世界编写的代码，绝大多数都是这种对象+方法的形式，这称之为**面向对象编程**，今天我们还不会正式讲解面向对象编程，但同学们要建立起对象、方法的概念



###### 2. 第一份源码

jshell 执行过的代码，在 jshell 退出后下次再想用，就不方便调出来了，正式的代码都会保存在类文件中，类文件的后缀是 .java，也称为 java 源代码

######## 1) 源码结构

源码结构如下，一份源码中可以包含多个类，每个类中又可以包含多个方法，方法内再包含语句代码

```java
class A {
    方法1() {
        // 语句代码
    }
    
    方法2() {
        // 语句代码
    }
    
    入口方法() {
        // 语句代码
    }
}

class B {
    
}
```

这里我们关注其中一个特殊方法：入口方法。

入口方法的格式是固定的：

```java
public static void main(String[] args) {
    
}
```

以后我们就称它为 main 方法

* main 并不从属于任何对象（由 static 修饰）
* main 方法内就可以书写之前学过的那行代码 System.out.println("Hello, world") 
* 要注意与之前 jshell 中一点区别是，这里的每行代码以分号结束



刚才给大家介绍了源代码的结构

* 源代码中可以包含多个 class 类，每个类中再去套方法，方法内再去套代码，当我们把这些写好之后，能不能交给 JVM 来执行呢？
* 还不行，因为JVM不理解源码，需要通过 javac 开发工具把源代码编译成 class 字节码文件（这种字节码JVM可以理解）字节码文件的特点是后缀以 .class 结尾
* 最后再通过 java 工具可以将 class 字节码加载至 JVM，JVM 将字节码解释翻译为机器码，最终就可以由 CPU 执行啦。



######## 2) 编写 java 源代码

进入 `d:` 盘

* 目的是为了找到一个合适存储 java 源代码的位置，也可以是其他位置，总之方便你找到它

```
C:\Users\Lenovo>d:

D:\>
```

运行记事本程序，notepad 是记事本程序名称

```
D:\>notepad
```

会打开如下窗口

![image-20220427101428725](image-20220427101428725.png)

输入如下代码

```java
class Hello {
    public static void main(String[] args) {
        System.out.println("hello, world");
    }
}
```

* `""` 内的 hello, world 是我们自由书写，可以是英文、汉字
* `class` 后的 Hello 称之为【类名】，一般是英文单词
* 其余代码要与例子中的【完全一致】，并严格区分大小写

保存文件，选择 `文件->保存` 或按它对应的快捷键 `Ctrl+S`

![image-20220427102858662](image-20220427102858662.png)

* 类名与最后的文件名请保持一致，保存为文件名以 `.java` 结尾
* 保存文件时，确保也存储于 `d:` 盘，方便待会找到它
* 编码位置也要注意，可能会影响到汉字的输出，后面会讲



######## 3)  编译 java 源代码

关闭记事本程序，回到命令提示符程序，输入下面命令

```
D:\>javac Hello.java
```

* `javac` 用来把一个 `*.java` 文件编译成 `*.class` 文件

* `*.class` 就是前面提到的 class 字节码

本例中，生成的字节码文件为 `Hello.class`，可以用 `dir` 命令查阅如下

![image-20220427105142579](image-20220427105142579.png)



######## 4)  运行 class 字节码

输入下面命令

```
D:\>java Hello
hello, world
```

* `java` 命令用来把 Hello.class 加载到 JVM 并执行它



###### 3. 常见问题

######## 中文输出乱码

有的同学编写代码时用了中文

```java
class Hello {
    public static void main(String[] args) {
        System.out.println("你好");
    }
}
```

编译、执行后输出为

```
浣犲ソ
```

> 发音：huan chai so

原因在于，保存 Hello.java 文件时，选择了 UTF-8 编码，而 javac 编译时采用的是操作系统默认编码 GBK，只要两边编码不一致，就会发生上述的【乱码】问题

############ 解决方法1

保存文件时，选择编码为 ANSI（对于记事本程序 ANSI 其实就是 GBK）

![image-20220427175121845](image-20220427175121845.png)



############ 解决方法2

文件保存时，编码仍然是 UTF-8 不变，编译时改用下面的命令明确告诉编译器，编译时别用默认的 GBK，改用 UTF-8

```
D:\>javac -encoding utf-8 Hello.java
```



######## 编译错误

有的同学在执行 javac 时会遇到各种各样的问题，例如

```
D:\>javac -encoding utf-8 Hello.java
Hello.java:3: 错误: 非法字符: '\uff1b'
        System.out.println("你好")；
                                         ^
1 个错误
```

遇到这种错误不用怕

* 其中 `Hello.java:3` 意思是说，Hello.java 中第 3 行出现错误，这样就可以定位错误位置
* 接下来它又提示了具体错误原因：`错误: 非法字符: '\uff1b'`，本例中是因为输入了中文分号 `；`，java 语法要求语句结束符号是英文分号 `;`
* 这些错误原因需要慢慢积累，见的多了就知道该怎么解决了



###### 4. 注释

注释就是对程序代码的一个说明，比如：

* 将来写的代码多了，你记性又没那么好，怕忘记某些代码的含义，这时候可以给它加一个注释
* 或是某些代码比较重要、特殊，这时也可以加一个注释进行说明

强调一点，注释只是对代码的说明，只影响代码阅读，不影响代码的功能。

注释的格式分成了单行注释，多行注释，还有文档注释三种。

######## 单行注释

 写在被注释代码的上方或右方，格式为

```java
// 注释内容
```



######## 多行注释

如果注释内容比较长，都写在一行影响阅读，这时候就用多行注释，格式为

```java
/*
	注释内容
	注释内容
*/
```



######## 文档注释

文档注释我们后面讲方法时再详细来讲吧，那现在呢，你只要了解它的格式：格式为：

```java
/**
	注释内容
*/
```





###### 5. 思考-为何需要字节码

咱们先回忆一下 Java 程序的开发以及运行的流程

* 首先得编写一个Java的源文件，源文件编写好了就能交给CPU来执行吗？
* 还不行啊，他得经过一个编译的步骤，也就是用那个javac程序把它编译成字节码文件
* 这个字节码文件呢，再经过一个叫 java 程序加载到 jvm 虚拟机，
* jvm 虚拟机其实还做了一件很重要的事，就是把字节码文件给解释成机器码
* 机器码就是最为底层的代码了，CPU就可以识别和运行它

所以整个流程是先把源文件变成字节码，再把字节码变成机器码，最终由CPU执行。



那这里大家可以思考这么一个问题，源代码，最终要变成机器码，是不是才能被CPU执行，那为什么我们不直接把Java 源码翻译成机器代码，而是多出了字节码这么一个中间环节呢？

######## C++ 的翻译过程

要解释清楚这个问题啊，我们就必须介绍一点历史。在Java语言发明之前呢，有一个比较流行的编程语言叫做c++语言，这个c++语言它就没有中间的环节，可以把源文件直接他翻译成最终的机器码。有同学说这不挺好？但是呢有这么一个问题：不同平台下的这个机器码是不通用的。

举个例子，在windows平台下编写好了c++源代码，可以把它经编译器编译为windows平台的机器码，但是这个机器码呢，只能用在windows平台。想拿到Linux平台下用，用不了。必须在 Linux 平台下，重新编译成Linux机器码。看看这样的缺点

1. 项目规模大了，源码编译也挺耗时间，在 windows 下编译一遍比如用了 20 分钟，测试通过了，将来要部署到 Linux 平台，又得编译一遍，再花 20 分钟... 时间都花在编译上了
2. 程序员还得熟悉两个平台，做不到开发与部署环境相分离

说完了这是c++程序需要多次编译缺点，那咱们再来看看 Java 是怎么解决这个问题的。

![image-20220427170358366](image-20220427170358366.png)

######## Java 的翻译过程

Java做的就是加入了字节码这个中间环节，不管是在Linux下的编译还是在windows下的编译，生成的字节码是所有平台都通用的，你在windows平台生成的字节码在Linux平台一样用，反之亦然。可以看到

1. 编译只需要一次，编译时间被节省了
2. 程序员只需要工作在自己熟悉的平台上就可以了，做到了开发与部署环境的分离

这就是 java 所宣称的 write once run anywhere，编写一次，到处运行。

字节码虽然带来了这样一些便利，但大家思考一下，有什么问题吗？

对啦，问题就是字节码不是最终的机器码

* 需要在每个平台上安装 jvm 虚拟机，负责把字节码解释为机器码
* 另外因为引入了把字节码解释为机器码的步骤，性能上会有一定损失，当然 jvm 为了保证性能，内部会做很多优化，这等我们讲到 jvm 时，会有更深入的认识

![image-20220427170317028](image-20220427170317028.png)

######## 小结

通过初步对比 c++ 和 java 的不同编译策略，我们学习到一个词 trade-off，权衡。 

* c++ 直接编译生成机器码，性能无与伦比，但一旦改变平台，会带来额外的编译成本
* java 编译生成字节码，减少编译成本，增强灵活性，但性能不可避免受到影响，需要再通过其它方面补救

以后大家如果进入到程序设计的领域，就会明白，所谓设计更多的是在各个方面做出权衡，没有最佳，只有最适合。